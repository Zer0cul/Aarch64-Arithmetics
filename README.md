# Два плюс два на голом метале без ассемблера

## Инструменты
[Aarch64 GNU compiler collection](https://developer.arm.com/downloads/-/arm-gnu-toolchain-downloads)
В данном случае я использую версию 14.1.
Целевая (target) платформа -- Baremetal, скачивайте инструменты для вашей несущей платформы, в моем случае это
Windows (mingw-w64-x86_64) hosted cross toolchains.
для 32-битной Windows следует выбрать Windows (mingw-w64-i686) hosted cross toolchains, этот набор будет работать и под 64-битной Windows. Важно выбрать правильную целевую архитектуру AArch64 bare-metal target (aarch64-none-elf). Я использую Raspberry Pi 3B в качестве цели поэтому выбор AArch64. Если попытаться испльзовать набор AArch32 для 64-битной архитектуры, то отладчик не сможет правльно интерпретировать данный.

Для удобства возмём Visual Studio Code, плагин Native Debug, который реализует подключение gdb к эмулятору qemu
Ещё для удобства потребуется Hex Editor, есть плагин для Visual Studio Code, или можно использовать любой удобный для вас например HxD. 

Установите путь в системых переменных для запуска gdb и эмулятора qemu
запускаем виртуальную машину 
Можно использовать командную строку или окно терминала Visual Studio Code `Ctrl+~`
```
qemu-system-aarch64w -M raspi3b -s -S
```
Ключ -S ставит машину в останов сразу после запуска
-s запуск gdb на порту 1234, сокращение от -gdb tcp::1234

запускаем отладчик gdb 
```
aarch64-none-elf-gdb
```
и подлючаемся к машине. В строке приглашения gdb набираем
```
target remote localhost:1234
```
:1234 это порт для отладки который используется отладчиком по умолчанию.
нормальным ответом отладчика будет
```
(gdb) target remote localhost:1234
Remote debugging using localhost:1234
warning: No executable has been specified and target does not support
determining executable automatically.  Try using the "file" command.
0x0000000000000000 in ?? ()
```
Если будет другой ответ с предупреждением, то скорее всего вы использует gdb из другого набора, скорее всего это AArch32. Посмотрите список доступных архитектур gdb, выполнив в его командной строке команду
```
set architecture
```
нормальным ответом будет наличие архитектуры "aarch64".
```
(gdb) set architecture
Requires an argument. Valid arguments are aarch64, aarch64:llp64, aarch64:ilp32, aarch64:armv8-r, arm, armv2, armv2a, armv3, armv3m, armv4, armv4t, armv5, armv5t, armv5te, xscale, iwmmxt, iwmmxt2, armv5tej, armv6, armv6kz, armv6t2, armv6k, armv7, armv6-m, armv6s-m, armv7e-m, armv8-a, armv8-r, armv8-m.base, armv8-m.main, armv8.1-m.main, armv9-a, arm_any, auto.
```
Если нет, установите правльный набор для вашей несущей ОС
Например для 64 разрядной виндовс правильный набор будет такой:
Windows (mingw-w64-x86_64) hosted cross toolchains.
AArch64 bare-metal target (aarch64-none-elf)

Набрав команду `info reg` в командной интерфейсе отладчика посмотрим состояние регистров.

## Два плюс Два на константах
Пусть наша первая программа будет складывать на константы загруженые в регистры.
Пояснять как процессор выполняет команду за командой, увеличивая каждый раз адресс, выходит за рамки этого упражнения. Всё что вы должны помнить
команды располагаються в памяти последовательно, от младших адресов к старшим, специальный регистр PC (Program Counter) указывает адрес следующей исполняемой команды.
Aarch64 имеет 32 регистра общего назначения с именами x0-x31. Некоторые их этих регистров имеют особые функции, например, по соглашению в x0
содержится результат функции по возврату. В этом примере мы будем использовать регистры x0 и x1

Алгоритм для программы выглядит следующим образом:
1. Загрузим в регистр х0 константу 2
2. Загрузим в регистр х1 константу 2
3. Сложим значение x0, x1 результат поместим в x0
4. Останов

На ассемблере программа будет выглядеть так:
```
MOV X0, #2
MOV X1, #2
ADD X0, X0, X1
HLT
```

Обратите внимание, на немного "нестандартный" синтаксис команды ADD, обычно, в языках ассемблера используються преемущественно два аргумента:
источник и назначение. Здесь, первый аргумент --- Rd указывающий регистр назначения, тот в который будет помещён результат, два следующих это Rn и Rm, регистры в которых находятся слогаемые. В целом это удобно, так как можно оставить регистры аргументов без изменений. Это особенность архитектуры RISC, большое количество регистров и их можно использовать как память, в отличии от x86 архитектуры, где набор регистров общего назначения серьёзно ограничен до восьми и каждый регистр кроме арифметических функций играет определённую роль. 
Пусть вас не смущает Rd, Rn, Rm -- это имена которые используються в документации по архитектуре и обозначают регистр общего назначения (General Purpose Register), т.е вместо этих символических имен можно подставить один из 31 регистров x0-x30 разрядностью 64-бит, а взависимости от флага sf в команде можно использовать регистры w0-w30 разрядностью 32-бит. Физически это теже самые регистры только обработка данных в них выполяется на младших 32=х разрядах.

#2 вероятно, вы догадались --- это обозначение константы, которая будет закодирована непосредственно в команде.

Конечно, в этот момент можно использовать ассемблер и линковщик из набора GNU Compiler Collection, но это тема для другой главы.

Кстати, x86 несовсем верное название, в документации Intel она обозначается как IA-32 и Intel64 для 32-х и 64-х разрядных режимов соотвественно.

### Транслируем в исполняемый код
Трансляция --- процесс перевода из одного языка в другой. Практически всегда выполняется один к одному без оптимизации. 
В данном случае четыре команды на языке ассемблера будут соответствовать четырём машинным инструкциям. 
Три главных вопроса при трансляции.
Что? Куда? Как?
Конечно в реальной жизни мы будем использовать транслятор ассемблера или компилятор языка С с последующей линковкой.
Но в этом примере и нескольких следующих мы выполним трансляцию вручную, так сказать по-старинке, чтобы понять процесс в целом
и в последующем это вам поможет понять процесс компиляции и линковки и разобраться в соглашениях о вызовах.

#### Что? --- источник
Самый простой вопрос в этой троице. Имеем программу на языке ассемблера, которую нужно перенести в машинный код, для исполнения на эмуляторе.
```
MOV X0, #2
MOV X1, #2
ADD X0,X0,X1
HLT
```
#### Куда? --- приемник
Не буду вас утомлять, создавайте файл пустой файл kernel8.img и открывайте его в Hex редакторе. Raspberry Pi 3 имеет довольно сложный механизм загрузки, описание которого выходит за рамки этой главы. На данный момент необходимо знать что kernel8.img подразумевает активацию и исполнения кода в 64-битном -- нормальном режиме, а kernel7.img 32-битном режиме совместимости со предыдущими платформами и архитектурами ARMv7.

Так как у нас четыре команды, забегая вперёд команды в AArch64 всегда имеют ширину слова (word), т.е 32 разряда. Поэтому смело добавляйте 16 байт всё заполняйте нулями. Забеuая вперед скажу, код из файла-образа kernel8.img загружается по адресу 0x80000 для Raspberry Pi 3

#### Как? --- инструмет

Информацию по регистрам и архитектуре можно получить по ссылке [Arm Architecture Reference Manual for A-profile architecture](https://developer.arm.com/documentation/ddi0487/latest/)
[Справочник по иструкциям](https://developer.arm.com/documentation/ddi0602/2024-12/?lang=en), также доступен в документации по архитектуре. Веб-версия может оказаться более удобная для чтения и быстрой справки о команде.

Следует обратить внимание на следующие разделы, я приведу строго необходимую информацию ниже
 - A1.4 Supported data type
 - B1.2 Register in AArch64 Execution state
 - С1.2.6.1 General-purpose register file and zero register and stack pointer
 - B2.8 Alignement support, Instruction alignment
 - B2.9 Endian support, Instruction endian
 - С1.1 About A64 instruction set
 - дополнительный раздел С4 A64 Instruction Set Encoding, C4.1 C4.1.1 на текущий момент достаточно.

Основные моменты важные для данного задания-упражнения:
- машинное слово (word) 32-бита. A1.4
- 31 регистр общеного назначения x0-x30 или w0-w30 64-бита и 32-бита соотвественно, на которых выполняються логические и арифметические операции. регистр X30 используется для связи с вызывающей процедурой. Регистр PC программно не досутпен содержит адрес выполняемой команды. может быть изменён только иструкциями ветвления или переходами по исключительным ситуациям. B1.2, C1.2.6.1 
- Важно! Адресс команды должен быть выровнен на границу слова word, т.е. 32-бита. т.е. адрес команды, например,0х00000002 или 0х00000005 не допустим переход по такому адресу вызовет ислючение. B1.2,B2.8
- Все инструкции имеют ширину 32-бита, т.е. слово(word). И это обеспечивает соблюдение требований указаных в B1.2,B2.8, в случае когда одна команда идет за другой вам нет необходимости помнить о выравнивании.C1.1
- Самая сложная часть B2.9 Endian support, Instruction endian. прочитайте её три раза. 
    **Младший байт команды расположен по младшему адресу**
    Здесь необходимы пояснения. Команда длиной 32-бита(word) состоит из 4 байт. Если вы откроете редактор HEX, то байты по будут расположены слева на право по возрастанию адресов. Если еще раз внимательно посмотрите на картинку Figure B2-2 Endianness relationships секция B2.9 Endian support, её нижнюю часть Little-endian memory system. то младший байт(B_A) команды окажется справа --- в самом младшем байте, а старший B_A+3 левее. В редакторе этот байт будет левее.
    Почему сложно? потому что при ручной трансляции вам постоянно надо переворачивать байты, и следить за границей байта, помнить, где старший бит предыдущего байта. И ещё
    **"Внутри" байта биты не "переварачиваются"**
    Довольно сложное и утомительное ментальное упражнение, когда вы его освоите мир перестанет быть прежним.

Если вы сразу не поняли в чем сложность, не страшно! У нас целых 4 команды на которых мы потренируемся.

Я предлагаю начать трансляцию с команды HLT, она простая, не содержит аргументов. после того как мы её переведем в машинный код, продублируем 4 раза, убедимся что трансляция выполнена правильно. После этого будем переписывать команду за командой, а последняя уже будет HLT. 

Если вы ещё не создали файл kernel8.img, то самое время это сделать. Если у вас Visual Studio Code c установленым плагином Hex Editor. Правой кнопкой на файле и открыть с помощью Hex Editor. Смело добавляйте 16 байт 0x00. и сохраняйте.
Такая команда интерпретируются процессором как "не определена" UDF. Для удобства, лучше перевести режим редактирования со вставки на замену клавишей `Insert`, или справа внизу сменить insert на replace

##### Начинаем трансляцию. HLT

Открываем раздел C6.2.150 HLT
или [HLT](https://developer.arm.com/documentation/ddi0602/2024-12/Base-Instructions/HLT--Halt-instruction-?lang=en)

31	30	29	28	27	26	25	24	23	22	21	20	19	18	17	16	15	14	13	12	11	10	9	8	7	6	5	4	3	2	1	0
1	1	0	1	0	1	0	0	0	1	0	imm16	                                                        0	0	0	0	0
                                opc		                                                                    op2	        LL

imm16 в данном случае будет 0
будем декодировать справа налево, и результаты записывать в файл kernel8.img 16ричном виде.
первые 8 бит слева (0-7) все равны 0 поэтому первый байт 0x00
```
00 
```
биты с 8-15 тоже равны нулю поэтому второй байт по адресу 0x01 будет равен нулю
```
00 00
```
третий байт команды биты с 16-23 уже содержат единички поэтому чтобы не запутаться переводим по полубайтам - по 4 бита
16-19 равны нулю
```
00 00 ?0
```
я использую сначала запись в текстовый файл, символ '?' обозначает что старший полубайт ещё не транслирован. в целом можно сразу в тексте записать
четыре байта для наглядности
```
00 00 ?0 ??
```
биты с 20 по 23 содержат 1 в 22 бите. 20 бит относится к imm16, который принят за 0 поэтому, старший полубайт будет 0x4, а промежуточный результат
после трансляции трех байт
```
00 00 40 ??
```
остался последний четвертый байт команды по адресу 0x03. Кстати это адрес относительно начала файла, правльно даже будет сказать смещение.
Биты команды с 24-31 тоже разобъем на полубайты младший 24-27 и старший 28-31
транслируем сначала младший 26 бит равен 1 остальные нули, т.е. 2^2=4
```
00 00 40 ?4
```
теперь старший полубайт биты с 28-31. 2^0 +2^2+2^3=13 или 0xD
И вот окончательный результат
```
00 00 40 D4
```

мы закодировали команду HLT для процессора, теперь скопируйте или наберите эти четыре байта ещё 4 раза. всего должно получиться 16 байт.
или одна строчка, обычно Hex редакторы традиционно выровнены на 16 байт.
```
00 00 40 D4 00 00 40 D4 00 00 40 D4 00 00 40 D4
```

Я предлагаю, перевести ещё одну команду, и приступить к проверке стенда. На текущий момент мы не сможем проверить правильность трансляции, да и смотреть особо не на что.

##### Начинаем трансляцию. MOV X0, #2
Следующаяя, а точнее первая наша команда это загрузка константы в регистр x0
```
MOV X0, #2
```
раздел C6.2.251 MOV (wide immediate)
или
[MOV immidate](https://developer.arm.com/documentation/ddi0602/2024-12/Base-Instructions/MOV--inverted-wide-immediate---Move-inverted-wide-immediate-value--an-alias-of-MOVN-?lang=en)

Обратите внимание что imm16 можно загрузить только значение от 0 до 65535. т.е. константу 64 разряда 
такой командой не загрузишь. Впрочем можно загрузить со сдвигом влево, это я вам оставлю на поэкспериментировать
самостоятельно

31	30	29	28	27	26	25	24	23	22	21	20	19	18	17	16	15	14	13	12	11	10	9	8	7	6	5	4	3	2	1	0
sf	1	0	1	0	0	1	0	1	hw	    imm16	                                                        Rd
    opc			

Как видим тут есть ряд полей которые надо задать перед тем как кодировать
imm16 - наша константа 2. биты 5-20 в битовом виде будет 0000000000000010b
sf - флаг ширины 1 - регистры x0-x30 64-битные, 0 регистры w0-w30 32-битные
hw - биты 21-22 указывающие на сколько бит будет произведён сдвиг, нам это не надо поэтому 00b
Rd - номер регистра назначения, буква d. будем грузить в X0 поэтому биты с 0-4 равны 0 = 00000b обратите внимание 5 бит(!)

начнем справа налево, помним что команда всегда 4 байта(32 бита)
```
?? ?? ?? ?? 
```
первый байт младший полубайт 0-3, поле Rd = 0 0000b берём младшие 4 бита
```
?0 ?? ?? ??
```
первый байт, старший полубайт биты с 4-7. Здесь немного сложнее -- два поля: Rd и imm16. У нас остался старший бит в поле Rd записываем его в младший разряд, и промежуточный результат полубайта ???0b. и первые три младших бита из поля imm16=0000 0000 0000 0010b. младшие три бита это 010b записываем их вместо вопросов
0100b=0x4 это значение старшего полубайта. Очень легко ошибиться. 

результат после трансляции первого байта команды
```
40 ?? ?? ??
```
давайте запишим остаток от imm16 в виде битов группируя по 4 для удобства чтения 0 0000 0000 0000. Как видите, у нас 3 нулевых полубайта.
Но не будем торопиться запишим пока второй байт биты 8-15
```
40 00 ?? ??
```
в imm16 нам осталось записать всего 5 бит 0 0000b. продолжим младшим полубайтом биты 16-19
```
40 00 ?0 ??
```
старший полубайт третьего байта команды биты 20-23. Внимательно, бит 23 равен 1, биты hw = 00b, и 20 бит самый старший бит от imm16 = 0b
получается 2^3=1=0x8 запишим результат
```
40 00 80 ??
```
младший полубайт четвёртого байта биты 24-27 0010b=0x2
```
40 00 80 ?2
```
старший полубайт четвертого байта биты 28-31. Флаг sf=1 поэтому 1101b=0xD
```
40 00 80 D2
```
поздравляю, первая команда нашей программы закодирована. на текущий момент файл должен выглядеть так
```
40 00 80 D2 00 00 40 D4 00 00 40 D4 00 00 40 D4
``` 
Я предлагаю немного сократить тренировку, так как вторая команда отличается от первой номером регистра X1 который очевидно 0 0001b для поля Rd, остальные поля одинаковые
и мы точно знаем что 0 бит не находиться на стыке полубайтов. поэтому для второй команды
```
MOV X1, #2
```
код команды выгядит вот так
```
41 00 80 D2
```
записываем команду файл kernerl8.img начиная со смещения 0x3, 
```
40 00 80 D2 41 00 80 D2 00 00 40 D4 00 00 40 D4
```

Осталась одна команда, давайте проверим промежуточный результат

##### Проверим правильность трансляции через gdb

Предполагаю, что вы настроили системные пути для qemu и gdb
запустите два окна терминала в Visual Studio Code `Ctrl+~` или в командной строке
в первом запустите эмулятор с указанием файла образа

```
qemu-system-aarch64 -M raspi3b -s -S -kernel kernel8.img
```
-s запустит поддержку gdb на стороне эмулятора
-S выполнит останов кода сразу по запуску эмулятора, это позволит перейти к отладке ядра
-kernel <image file> путь к файлу образа

во втором окне запустите gdb
```
aarch64-none-elf-gdb
```
после этой команды вы увидите приглашение (gdb) для команд.

давайти установим точки остановки для нашего файла 
в стартовой точке и в финальной, по адресам 0x80000 и 0x8000C
```
b *0x80000
b *0x8000C
```
добавим к выводу текущую команду в виде ассемблера, кстати добавив число перед i можно вывести несколько команд
```
display /i $pc
```

Подключимся к эмулятору командой
```
target remote localhost:1234
```
Вы увидите что-то вроде этого
```
Remote debugging using localhost:1234
warning: No executable has been specified and target does not support
determining executable automatically.  Try using the "file" command.
0x0000000000000000 in ?? ()
1: x/i $pc
=> 0x0: ldr     x0, 0x18
```
обратите внимание что эмулятор сейчас остановлен по адресу 0х00, помните ключ -S 
выполните команду 'c' - continue, и если всё сделано как надо, и правильно выставлена точка останова на адресе 0x80000
```
c
```
вывод на экран должен быть следующий
```
(gdb) c
Continuing.

Thread 1 hit Breakpoint 1, 0x0000000000080000 in ?? ()
1: x/i $pc
=> 0x80000:     mov     x0, #0x2                        // #2
```
Если вывод отличен от этого, решите проблему перед тем как двигаться дальше.
потенциальные проблемы:
- Эмулятор не остановился по адресу 0x80000 - проверьте установку контрольных точек.
- команда отличная от mov x0, #2, проверьте правильность трансляции и внесения данных. Два раза.

Предположем, что всё хорошо и у вас получилось добиться такого же результата
давайте выполним эту команду на эмуляторе и посмотрим состояние регистров
```
stepi
```
сделает следующий вывод на экран, который означает что первая команда выполнена
```
(gdb) stepi
0x0000000000080004 in ?? ()
1: x/i $pc
=> 0x80004:     mov     x1, #0x2                        // #2
```
Проверьте что вторая команда выгядит так как задумывалось, и проверим состояние регистров командой
```
info reg
```
Как видим x0 содержит необходимую константу 2
```
(gdb) info reg
x0             0x2                 2
x1             0x0                 0
x2             0x0                 0
x3             0x0                 0
x4             0x80000             524288
x5             0x0                 0
x6             0x0                 0
x7             0x0                 0
--Type <RET> for more, q to quit, c to continue without paging--
```
Давайте выполним вторую команду через `stepi` и посмотрим на состояние регистров
```
(gdb) stepi
0x0000000000080008 in ?? ()
1: x/i $pc
=> 0x80008:     add     x0, x0, x1
(gdb) info reg
x0             0x2                 2
x1             0x2                 2
x2             0x0                 0
x3             0x0                 0
x4             0x80000             524288
x5             0x0                 0
x6             0x0                 0
x7             0x0                 0
--Type <RET> for more, q to quit, c to continue without paging--
```
Константы загружены в регистры. Вы можете закрыть отладчик, тогда вам придется устанавливать точки останова повторно, лучше оставить открытым
##### Трансляция последней команды ADD X0,X0,X1
ADD X0,X0,X1
Открываем главу в Arm® Architecture Reference Manual
for A-profile architecture
C6.2.6 ADD (shifted register)
или по ссылке
[ADD (shifted register)](https://developer.arm.com/documentation/ddi0602/2024-12/Base-Instructions/ADD--shifted-register---Add-optionally-shifted-register-?lang=en)

31	30	29	28	27	26	25	24	23	22	21	20	19	18	17	16	15	14	13	12	11	10	9	8	7	6	5	4	3	2	1	0
sf	0	0	0	1	0	1	1	shift	0	Rm	                imm6	                Rn	                Rd
    op	S							

ADD <Xd>, <Xn>, <Xm>{, <shift> #<amount>}

Эта команда складывает регистры указаные в полях Rm и Rn помещая значение Rd, при этом опционально можно применить операцию сдвига ко второму операнду Rm.
Здвигать нам не требуется поэтому
sf = 1b используем 64-битные регистры x0-x30
imm6 = 00 0000b количество бит сдвига
shift = 00b логический сдвиг влево LSL, можно выбрать любой кроме зарезервированного. значение 00b проще кодировать поэтому не усложняем
Rd - x0 регистр назначения 0 0000b
Rn - x0 первый операнд 0 0000b
Rm - x0 второй операнд 0 0001b

первый байт биты 0-7 поля Rd, Rn 0000 0000b, старшие биты поля Rn 00b будут задействованы в следующем байте 
```
00 ?? ?? ??
```
второй байт биты 8-15 старшие два бита поля Rn=00b и 6 бит поля imm6=00 0000b  в результате 0000 0000b 
```
00 00 ?? ??
```
третий байт, биты 16-23 младшие 5 бит поле Rm=0 0001b, 21 бит =0, и shift = 00b
```
00 00 01 ??
```
четвёртый байт биты 24-31  поле sf=1b и заданные значения 1000 1011b=0x8B
```
00 00 01 8B
```
Записываем полученые байты в файл kernel8.img начиная со смещения 0x8
```
40 00 80 D2 41 00 80 D2 00 00 01 8B 00 00 40 D4
```
В общем, это всё наши четыре команды программы на языке ассемблера оттранслированы вручную в четыре команды каждая 32-бита шириной, всего 16 байт

Остаётся только проверить результат через gdb.

### Проверка финального результата
закройте эмулятор если он у вас открыт, и запустите новый с обновлым фалом kernel8.img
```
 qemu-system-aarch64w -M raspi3b -s -S -kernel kernel8.img
```
переключитесь в окно gdb и выполните переподключение к эмулятору
```
target remote localhost:1234
```
на предложение остановить текущую отладку ответье y
Если вы не закрывали окно отладчика, то точки останова у вас остануться, если вы отрыли отладчик заново то необходимо устаность точки останова командой `b`
```
b *0x80000
b *0x8000C
```
запускаем эмулятор командой `c` до первой точки останова по адресу 0x80000
```
(gdb) c
Continuing.

Thread 1 hit Breakpoint 1, 0x0000000000080000 in ?? ()
1: x/i $pc
=> 0x80000:     mov     x0, #0x2                        // #2
```
Выполните 3 раза stepi, проверяйте правильность трансляции команды
```
Thread 1 hit Breakpoint 1, 0x0000000000080000 in ?? ()
1: x/i $pc
=> 0x80000:     mov     x0, #0x2                        // #2
(gdb) stepi
0x0000000000080004 in ?? ()
1: x/i $pc
=> 0x80004:     mov     x1, #0x2                        // #2
(gdb) stepi
0x0000000000080008 in ?? ()
1: x/i $pc
=> 0x80008:     add     x0, x0, x1
(gdb) stepi

Thread 1 hit Breakpoint 2, 0x000000000008000c in ?? ()
1: x/i $pc
=> 0x8000c:     hlt     #0x0
(gdb)
```

и финальный резултат командой info reg
```
(gdb) info reg
x0             0x4                 4
x1             0x2                 2
x2             0x0                 0
x3             0x0                 0
x4             0x80000             524288
x5             0x0                 0
x6             0x0                 0
x7             0x0                 0
x8             0x0                 0
x9             0x0                 0
x10            0x0                 0
--Type <RET> for more, q to quit, c to continue without paging--
```

X0 содержит 0х4, что соотвествует задумке написанной программы
```
MOV X0, #2
MOV X1, #2
ADD X0,X0,X1
HLT
```
Которая складывает две константы
Х1 содержит 0х2,  это один из аргументов загруженный второй командой

## Заключение
На заре развития вычислительной техники процесс выглядел примерно так, только у них не было отладчиков и эмуляторов.
Каждый день вряд ли придётся заниматься подобной активностью. Знание процесса и инструментов будет точно не лишним.
А самое главное эти знания и навыки переносяться на любую платформу с которой вам предстоит работать. AArch64 выбрана
по причине удобства работы и потому что она одна из наиболее актуальных платформ на момент написания.

Какие знания мы получили:
1. Архитектура AArch64, типы и форматы данных, регистры, команды, выравнивание данных и команд, порядок следования байт  
2. Как переводить прогамму в машинный код в ручную без ассемблера
3. Работу с отладчиком: как устанавливать точки останова, смотреть регистры, подключаться к платформе

## Материалы, руководства и ссылки на инструменты
### Использованые инструменты
[Загрузка QEMU](https://www.qemu.org/download/#windows)
[QEMU для window 64](https://qemu.weilnetz.de/w64/)
[Aarch64 GNU compiler collection](https://developer.arm.com/downloads/-/arm-gnu-toolchain-downloads)
Опционально
[Visual Studio Code](https://code.visualstudio.com/)
Hex Editor plugin for VS Code идентефикатор ms-vscode.hexeditor
### Руководства и справочники
[Arm Architecture Reference Manual for A-profile architecture](https://developer.arm.com/documentation/ddi0487/latest/) - Справочное руководство по архитектуре, в формате pdf
[Справочник по иструкциям AArch64](https://developer.arm.com/documentation/ddi0602/2024-12/?lang=en)
[Learn the architecture - A64 Instruction Set Architecture Guide](https://developer.arm.com/documentation/102374/0102) - обучения командам c примерами и задачами на проверку знаний 

### Команды gdb
запуск gdb 
```
 aarch64-none-elf-gdb
```
Использованые команды gdb
```
set architecture
b *0x80000
b *0x8000C
info reg
display /i $pc
display /i $x0
stepi
target remote localhost:1234
c
continue
```
### Запуск эмулятора
без образа, с остановом и поддержкой gdb
```
qemu-system-aarch64w -M raspi3b -s -S
```
с образом с остановом
```
qemu-system-aarch64w -M raspi3b -s -S -kernel kernel8.img
```
