# Два плюс Два в памяти
## Ссылки и инструменты
### Инструменты
* Эмулятор [QEMU для window 64](https://qemu.weilnetz.de/w64/)
* Компилятор, сборщик, отладчик [Aarch64 GNU compiler collection](https://developer.arm.com/downloads/-/arm-gnu-toolchain-downloads)
* Отладчик gdb


## Цели, задачи
Цель предыдущего упражнения была познакомить с принципом ручной 
трансляции. Это упражнение направлено изучения основ работы с памятью
Как и в первом упражнении вам не потребуется специфических знаний
об инструментах, таких как ассемблер или линковщик, только 
документация по платформе, и знание небольшого количества фактов, 
которые уже вам известны из первого упражнения. В этом упражнении мы 
также применим ручную трансляцию, только разбирать её подробно 
не будем, ограничимся обозначением команды, и описанием полей.
Мы сделаем пять примеров адресации памяти:
* относительно PC(Program Counter)
* относительно PC c выравниванием на 4K - страница
* Базовый регистр плюс смещение
* Пре-индексная
* Пост-индексная

В этих примерах я не буду останавливаться на различных типах данных, 
предлагаю вам попробовать самостоятельно.

### Зачем работать с памятью, я тут на констанах всё могу посчитать.
В первом примере мы использовали констаны непосрественно 
закодинованные в команду, используя команду MOV(wide immediate) 
из группу Data processing - immediate
такой способ имеет ограничения:
- значения констант 0-65535, обусловленно длинной поля 16 бит
- отсутствие возможности изменять входные значения, потребуеться 
повторная трансляция при новых входных значениях. В этом упражнении,
мы попробуем работать с "большими" числами.

Входные данные и выходные должны находится в памяти потому что
подавляющеей большинство команд устроены так. К слову 
сказать регистры процессора это тоже память  --- регистровая.

Для загрузки и сохранения значений из оперативной памяти в регистры PE
(processing element), по простому процессор, а точнее ядро процессора,
предназначена группа команд Loads and Stores (Загрузка и Сохранение) 
[C3.2 Loads and Stores]

Существует несколько способов указать адрес в памяти:
Секция [C3.2/1 Load/store register] перечисляет доступные режимы 
адресации 
- Только Базовый регистр
- Базовый регистр плюс смещение
- Пред-индексированный
- Пост- индексированый
- Относительно PC 

Мы рассмотрим на примерах ниже, каждый из этих режимов.
Более подробно о режимах адрессации [C1.3.3 Load/store addressing modes]

### Алгоритм 
Напомню алгоритм, который мы используем в прмерах
1. Загрузить число a в регистр x0
2. Загрузить число b в регистр x1
3. Сложить a и b результат поместить в x0

Это всё теория, перейдем к практике
## Пример 1. Относительно PC
Code\01-PCRelative 
Это самый простой для понимания, и сложный для исполнения пример.
### Алгоритм 
Напомню алгоритм, который мы используем в прмерах
1. Загрузить число a в регистр x0
2. Загрузить число b в регистр x1
3. Сложить a и b результат поместить в x0
4. останов
Итак, наша программа выглядит не больше 4
четырех команд. Если мы поместим данные сразу за командой HLT, 
то каждый раз на придется "двигать" область памяти предназначеную 
для данных и каждый раз пересчитывать смещиние. О чем это я?
Каждая команда это 32 бита 4 байта. Программа из примера с 
константами в памят выглядит 
```
Memory		Mnemonic	Address

младший адрес 0x0008 0000
v
+------------+
|40 00 80 D2 |	MOV X0, #2	<- 0x0008 0000-0x0008 0003
|41 00 80 D2 |	MOV X1, #2	<- 0x0008 0004-0x0008 0007
|00 00 01 8B |	ADD X0,X0,X1	<- 0x0008 0008-0x0008 000B
|00 00 40 D4 |	HLT		<- 0x0008 000C-0x0008 000F
|...
	     ^
	     старший адрес
```
Давайте предположим что мы расширим эту программу до 8 команд.
И расположим данны начиная с адреса 0x0008 0020. Оставим пока
код программы не изменным нас интересуют данные.
```
Memory		Mnemonic	Address

младший адрес 0x0008 0000
v
+------------+
|40 00 80 D2 |	MOV X0, #2	<- 0x0008 0000-0x0008 0003
|41 00 80 D2 |	MOV X1, #2	<- 0x0008 0004-0x0008 0007
|00 00 01 8B |	ADD X0,X0,X1	<- 0x0008 0008-0x0008 000B
|00 00 40 D4 |	HLT		<- 0x0008 000C-0x0008 000F
|00 00 00 00 |	----------
|00 00 00 00 |	Место по дополнителных команд
|00 00 00 00 |
|00 00 00 00 |	----------	<- 0x0008 001C-0x0008 001F
|02 00 00 00 |	Число a		<- 0x0008 0020-0x0008 0023	
|00 00 00 00 |
|02 00 00 00 |			<- 0x0008 0028-0x0008 002B
|00 00 00 00 |	Число b
|  ...	
	     ^
	     старший адрес
```
Запишим адреса наших меток
a: 0x0008 0020
b: 0x0008 0028

В этом момент, у вас должен начать ломаться мозг. 
Обратите внимание, что под а и b выделенно по 64-бита(8 байт)
Давайте попробуем загрузить числа в соотвествющие регистры
Используя адресацию относительно PC(Program Counter)
Первая команда исполняется по адресу 0x0008 0000
проверьте ещё раз раздел [C3.2.1 Load/store register]
И из таблици подберите команду с необходимой адресацией -- 
Load register (PC-relative literal)
[C6.2.192 LDR (literal)](https://developer.arm.com/documentation/ddi0602/2024-12/Base-Instructions/LDR--literal---Load-register--literal--?lang=en)
```
31	30	29	28	27	26	25	24	23	22	21	20	19	18	17	16	15	14	13	12	11	10	9	8	7	6	5	4	3	2	1	0
0	1	0	1	1	0	0	0	imm19																			Rt				
	op				VR
```
- imm19 - относительное смещение c знаком = 000  0000 0000  0000 1000b = 0x08
- Rt - регистр назначения x0 = 0 0000b

imm19 19бит смещение относительно текущего PC. для первой команды 
PC равен 80000, число `а` находится по адресу 80020, следовательно 
смещение будет равно 0x20 = 0010 0000b. Следует помнить что смещение может быть 
и отрицательным. Отрицательные числа представляются в формате Two's 
complamentary addition - дополнение до двойки, или второе 
компламентарное дополнение.

Внимательно читаем документацию, оносительное смещение имеет 
ограничение +-1МБ, а это 20 бит и плюс один бит на знак
Однако, в команде  константа шириной 19-bit, которая принципиально
не способна адресовать 1МБ. Обратите внимание что константа сдвигается
влево на 2 бита, т.е умножается на 4. Что означает, что данные должны 
быть выровнены на границу слова(word) 4 байт или 32 бит.
поэтому, значение необходимого смещения 0x20 сдвигаем влево на 2 бита
и уменьшено до 0x08 = 0000 1000b

### Первая команда  LDR X0, a
Итак наша команда будет выглядеть вот так
LDR X0, a
```
00 01 00 58
```
Сложность в трансляции преставляют младшие байты
```
0000 0001 0000 0000
------------||----|
imm19		Rt
```

### Вторая команда  LDR X1, b
Используем команду LDR для загрузки второй константы.
Следует помнить что адрес второй команды уже 0x0008 0004
а число по метке `b`на ходится по адресу 0x0008 0028
соотвественно смещение будет 0x24 = 0010 0100b
приготовим констану imm19, сдвинув смещение на 2 бита вправо
imm19 = 0000 1001b
Данные для трансляции:
imm19 = 000  0000 0000  0000 1001b
Rt - регистр назначения x1 = 0 0001b
LDR X1, b
```
21 01 00 58
```
```
0000 0001 0010 0001
------------||----|
imm19		Rt
```
### Программа на языке ассемблера 
ассемблер в синтаксесе GNU. Пример не полный так как 
к необходим файл для линковки. Иструменты и линковка отдельная тема
Здесь приведен код в качестве иллюстрации.
```
	.align 2
	.section .text
_start:	
	LDR X0, a
	LDR X1, b
	ADD X0,X0,X1
	HLT
.space 16 , 0x00
a:
	.word 0x2
	.word 0x0
b:	
	.word 0x2
	.word 0x0
```

### Программа в машинном коде
как и прошлом примере создайм  файл в Hex редакторе
kerne8.img и переносим данные
```
00 01 00 58 
21 01 00 58
00 00 01 8B 
00 00 40 D4
00 00 00 00 
00 00 00 00
00 00 00 00 
00 00 00 00
02 00 00 00 
00 00 00 00
02 00 00 00 
00 00 00 00
```
### Запуск и проверка
закройте эмулятор если он у вас открыт, и запустите новое окно с 
обновлённым файлом kernel8.img из каталога Code\01-PCRelative
```
 qemu-system-aarch64w -M raspi3b -s -S -kernel kernel8.img
```
Запустим отладчик
```
aarch64-none-elf-gdb
```
В отладчике установим точки останова по адресам 0x80000, 0x8000C
все следующие действия выполняем в окне отладчика
```
b *0x80000
b *0x8000C
```
Настроим отображение текущей команды и значение счетчика команд
```
display /i $pc
```
Подключаемся к эмулятору и запускаем прошивку на исполнение
```
(gdb)target remote localhost:1234
(gdb))continue
```
Следует ожидать вывода
```
Thread 1 hit Breakpoint 1, 0x0000000000080000 in ?? ()
1: x/i $pc
=> 0x80000:     ldr     x0, 0x80020
(gdb)
```
Как видим gdb сделал остановку по адресу  0x0000000000080000
и первая команда загрузит регистр x0 значением из памяти по адресу
0x80020.
Давайте проверим значение какое значение храниться по адресу 0x80020
```
(gdb) x 0x80020
0x80020:        0x00000002
```
Все верно, теперь выполним первую команду `stepi` и проверим значение по 
которое будет использовано для второй команды.
```
(gdb) stepi
0x0000000000080004 in ?? ()
1: x/i $pc
=> 0x80004:     ldr     x1, 0x80028
```
Сначала проверим какое значение хранится в регистре x0
команда gdb - i reg x0 
и значение числа b находится по адресу 0x80028
команда gdb - x 0x80028
```
(gdb) i reg x0
x0             0x2                 2
(gdb) x 0x80028
0x80028:        0x00000002
```
Все правильно.
Давайте выполним две команды подряд --
1. загрузка значения в x1
2. сложение x0 и x1 с результатом в x0
два раза выполните команду `stepi` в gdb
```
(gdb) stepi
0x0000000000080008 in ?? ()
1: x/i $pc
=> 0x80008:     add     x0, x0, x1

(gdb) stepi
Thread 1 hit Breakpoint 2, 0x000000000008000c in ?? ()
1: x/i $pc
=> 0x8000c:     hlt     #0x0
```
командой `i reg x0` проверим результат работы программы
```
(gdb) i reg x0
x0             0x4                 4
```
Все верно x0 содержит 4 -- результат сложения x0, x1. И у нас есть
персональный сумматор способный работать с 32-битными значениями.
Вы может поэкспериментировать со значениями по смещениям 0x20 и 
0x28 в файле kernel8.img

### Итоги первого примера
PC-relative простой способ загрузить значения из памяти в регистр,
но у него есть существенные ограничения, а именно:
- значения должны располагатся относительно текущей команты +- 
1Мбайт(20бит)
- Как только изменяется программа, необходимо пересчитывать смещение
относительно команды
Из плюсов для небольших программ, и с простой схемой расположения -
по фиксированным адресам, вычислить адрес относительно просто.

## Пример 2. Относительно PC с выравниванием на 4К
В этом примере будет несколько новых концепций, команд, и программных
трюков. Этот пример послужит основой для следующих упражнений.

Перед тем как начать создайте файл размером 8Кбайт заполненый нулями.
В папке Code\02-PCRalativePage файл TwoPageBlank.img сделайте его 
копию с именем kernel8.img

На этот раз мы расположим данные "дальше" в памяти. К ним всё ещё 
можно будет обратиться способом указаном в прмере выше, просто 
представьте что код у нас занимает на четыре команды, а 4 мегабайта.
В таком случае обращение с помощью PC-relative станет невозможным.

Итак, карта памяти для текущего примера выглядит следующим образом:
```
Memory		Mnemonic	Address

младший адрес 0x0008 0000
v
+------------+
|40 00 80 D2 |	MOV X0, #2	<- 0x0008 0000-0x0008 0003
|41 00 80 D2 |	MOV X1, #2	<- 0x0008 0004-0x0008 0007
|00 00 01 8B |	ADD X0,X0,X1	<- 0x0008 0008-0x0008 000B
|00 00 40 D4 |	HLT		<- 0x0008 000C-0x0008 000F
|00 00 00 00 |	----------	<- 0x0008 0010-0x0008 0013
|00 00 00 00 |	Место по дополнителных команд 4Кб
|...	     |
|...         |	----------	
|02 00 00 00 |	Число a		<- 0x0008 1000 Начало страницы 1 Отн. смещение 0x0000	
|00 00 00 00 |				
|02 00 00 00 |	Число b		<- 0x0008 1008 Смещение относительно начала страницы 1 = 0x0008
|00 00 00 00 |			
|  ...	
	     ^
	     старший адрес
```
Обратите внимание что адреса чисел а и b изменились
на 0x0008 1000 и 0x0008 1008 соотвественно.
4Kб - это страница(page). В этом примере условимся, что код у нас 
находится на странице 0, а данные на странице 1. Физические 
адреса остаются не изменные. Деление на страницы всего лишь наше
логическое представление. И тем не менее адреса начала страниц 
подчиняются строгим правилам --выровнены на 12 бит. 
Т.е. страница не может начинаться с адреса 0x98001, но 0x98000 вполне 
допустим. В адресе начала страницы должны быть последние три нуля.

4Кбайта много это или мало. По современным меркам это мало, однако
80x25 монохромный экран это чуть меньше 2 Кбайт, печатная страница 
около 4 килобайт. До этого момента размер этого файла 19Кбайт, 
но надо учитывать что кирилица это 2байта на символ в кодировке UTF-8,
в другой кодировке этот текст займёт около 8Кбайт, размер размер
можно соотнести с файлом, который мы создали в начале упражнения.

Итак, имеем две логические страницы:
- Page 0 по адресу 0x0008 0000 - код программы
- Page 1 по адресу 0x0008 1000 - данные

Чтобы упростить программу мы используем трюк и знание о том что 
первая команда выполняется по адресу 0x0008 0000  
из раздела Data processing - immediate [C3.5.6 PC-relative address
 calculation] 
нам потребуется команда ADRP

### Алгоритм 

1. Загрузить в регистр x3 адрес начала страницы данных.
2. Загрузить число a в регистр x0
3. Загрузить число b в регистр x1
4. Сложить a и b результат поместить в x0
4. останов
### Программа и трансляция
Нам потребуется дополнительный регистр для хранения адреса начала 
страницы и другие команды для загрузки данных используя этот адрес страницы.
В первом варианте мы будем работать с 32-битными значениями,
Потом мы внесем изменения для работы 64-битными значениями.

[C6.2.13 ADRP]
[C6.2.13 ADRP](https://developer.arm.com/documentation/ddi0602/2024-12/Base-Instructions/ADRP--Form-PC-relative-address-to-4KB-page-?lang=en)
```
31	30	29	28	27	26	25	24	23	22	21	20	19	18	17	16	15	14	13	12	11	10	9	8	7	6	5	4	3	2	1	0
1	immlo		1	0	0	0	0	immhi																			Rd				
op				
```
Обратите внимание что константа разбита на два поля immhi и immlo
эта константа будет умножена на 4096 -- размер страницы

immlo - младшие биты. Мы обращаемся к странице 1 соотвественно = 01b
immhi - старшие биты. Все равны нулю. 
Rd - x3 = 0 0011b 
Транслируем
```
03 00 00 B0
```

Для загрузки значений в регистры x0, x1 будем использовать команду
LDR (immediate) c режимом адресации
Base plus a scaled 12-bit unsigned immediate offset or 
base plus an unscaled 9-bit signed immediate offset.
База плюс маштабируемый 12-битное без знаковое смещение 
непосредственно в команде или
База плюс масштабируемое 9-битовое знаковое смещение непосредственно
в команде.

Давайте разберем База плюс масштабируемое 12-битное смещение.

Команда LDR (immediate) имеет три режима адресации, которые выбираются
битами 24, 10 и 11.
Эта команда может загружать 32-битные значения или 64-битные значения.
поле size отвечает за выбор ширины данных.   
Сейчас мы работаем с режимом Unsigned offset, 10 11 используются как 
младшие биты поля imm12. За выбор режима отвечает 24 бит, при 1 режим 
unsigned offset при 0 режим post- или pre-indexed и биты 10,11 
отвечают за выбор post или pre.

В документации более детально описан алгоритм, если изложить простым
языком для поля size=10b (32-битные значение) смещение imm12 будет 
указывать на каждые 4 байта, относительно базы. для поля size=11b 
(64-битные значения) смещение imm12 будет будет указывать на каждые
8 байт. Если вы не поняли ничего страшного в конце мы сделаем 
модификации, которые должны внести ясность.
Сейчас мы работаем с 32-битными значениями.

[C6.2.191 LDR (immediate)](https://developer.arm.com/documentation/ddi0602/2024-12/Base-Instructions/LDR--immediate---Load-register--immediate--?lang=en)
```
31	30	29	28	27	26	25	24	23	22	21	20	19	18	17	16	15	14	13	12	11	10	9	8	7	6	5	4	3	2	1	0
1	x	1	1	1	0	0	1	0	1	imm12												Rn					Rd				
size	      |				VR		|	opc    |	
```
загружаем первое заначение в X0
size = 10b
imm12 = 0000 0000 0000b - первое значение находится по смещению 0 
относительно начала страницы
Rd - регистр назначения x0= 0 0000b
Rn - регистр базы x3 = 0 0011b
0000 1000 0110 0000b
-------|----||-----|
imm12    Rn    Rd
транслируем команду LDR (immediate) X0, [X3, #0]
```
60 00 40 B9
```
Записываем команды начиная со смещения в файле 0x0004
Записываем число 2 `а` начиная со смещения в файле 0x1000
Записываем число 3 `b` начиная со смещения в файле 0x1008
Будьте внимательны!

```
Memory		Mnemonic	Address

младший адрес **0x0008 1000**
v
|            |	----------	
|02 00 00 00 |	Число a		<- 0x0008 1000 Начало страницы 1 Отн. смещение 0x0000	
|00 00 00 00 |				
|03 00 00 00 |	Число b		<- 0x0008 1008 Смещение относительно начала страницы 1 = 0x0008
|00 00 00 00 |			
|  ...	
	     ^
	     старший адрес
```

Теперь сделаем трансляцию команды LDR(immediate), которая загружает 
значение в регистр x1
поля для команды
size = 10b
imm12 = 0000 0000 0010b - 
Rd - регистр назначения x0= 0 0001b
Rn - регистр базы x3 = 0 0011b

Обратите внимание, что imm12=0x2, а не 8. Это из-за логики работы 
команды, как указывалось выше смещение отсчитывает по 4байта.
При выполнении команды смещение будет автоматически сдвинуто влево
на количество бит указаных в поле размер, т.е на 2 что соотвествует
умножению на 4. Таким образом во время исполнения команда вычислит 
правильное смещение X3+8, что соотвествует адресу нашего числа `b`.
Траслируем LDR	X1, [X3, #2]
[C6.2.191 LDR (immediate)](https://developer.arm.com/documentation/ddi0602/2024-12/Base-Instructions/LDR--immediate---Load-register--immediate--?lang=en)
```
31	30	29	28	27	26	25	24	23	22	21	20	19	18	17	16	15	14	13	12	11	10	9	8	7	6	5	4	3	2	1	0
1	x	1	1	1	0	0	1	0	1	imm12												Rn					Rd				
size	      |				VR		|	opc    |	
```
Внимательно, с младшими байтами
0000 1000 0110 0001b
-------|----||-----|
imm12    Rn    Rd

```
61 08 40 B9
```
Результат трансляции записываем по смещению 0x0008 в файле
записываем уже знакомы команды
```
00 00 01 8B 
00 00 40 D4
```
по смещениям 0x000C и 0x0010 соотвественно
```
Memory		Mnemonic	Address

младший адрес 0x0008 0000
v
+------------+
|03 00 00 B0 |	ADRP X3, a		<- 0x0008 0000-0x0008 0003
|60 00 40 B9 |	LDR  X0, [X3, #0]	<- 0x0008 0004-0x0008 0007
|61 08 40 B9 |	LDR  X1, [X3, #2]	<- 0x0008 0008-0x0008 000B
|00 00 01 8B |	ADD  X0,X0,X1		<- 0x0008 000C-0x0008 000F
|00 00 40 D4 |	HLT			<- 0x0008 0010-0x0008 0013
|00 00 00 00 |	Место по дополнителных команд 4Кб
|....	     |  Данные расположены дальше к старшим адресам
		начиная с адреса 0x0008 1000

	     ^
	     старший адрес


```
Проверьте что в установили данные по смещению в файле
0x0100 и 0x0108
### Проверка 32-разрядного результата.
Запускаем gdb
```

```
перед запуском эмулятора убедитесь в правильности каталога
02-LoadStoreNoAssembler\Code\02-PCRelativePage
Запускаем эмулятор
```
qemu-system-aarch64w -M raspi3b -s -S -kernel kernel8.img
```
в gdb необходимо добавить точку останова по адресу 0x80010
и выполните подключение к эмулятору
```
(gdb) b *0x80010
Breakpoint 3 at 0x80010
(gdb) target remote localhost:1234
```
Запускаем эмулятор до первой точки останова по адресу 0x80000
```
Thread 1 hit Breakpoint 1, 0x0000000000080000 in ?? ()
1: x/i $pc
=> 0x80000:     adrp    x3, 0x81000
```
Видим правильный адрес первой страницы 0x81000, Страница, где 
расположены данные. Выполняем шаг и проверяем значение регистра x3

```
(gdb) stepi
0x0000000000080004 in ?? ()
1: x/i $pc
=> 0x80004:     ldr     w0, [x3]
(gdb) i reg x3
x3             0x81000             528384
```
Регистр x3 содержит правильное значение.
Как видите gdb дизассемблировал команду на ширину 32-бита, поэтому
название регистра заменено на w0, для сокращения imm равно 0, 
также не указано.
Проверяем наличие значений по адресам 0x81000 и 0x81008
и выполняем команду на загрузку значения в регистр x0
```
(gdb) x 0x81000
0x81000:        0x00000002
(gdb) x 0x81008
0x81008:        0x00000003
(gdb) stepi
0x0000000000080008 in ?? ()
1: x/i $pc
=> 0x80008:     ldr     w1, [x3, #8]
(gdb) i reg x0
x0             0x2                 2
```
Значения находятся на местах, в регистр x0.
Обратите внимание на команду, точнее на значение смещения
Если помните, то в команде в поле imm12 мы указали значение 2
gdb преобразовал это значение в реальное смещение. Если мы сложим
значение x3=0x81000 и значение смещения 0x8 то получим 
физический адрес значения числа `b`. Давайте выполним 
две команды `stepi` подряд и посмотрим на результат исполнения
`i reg x0 x1 x3`
```
=> 0x80008:     ldr     w1, [x3, #8]
(gdb) i reg x0
x0             0x2                 2
(gdb) stepi

Thread 1 hit Breakpoint 2, 0x000000000008000c in ?? ()
1: x/i $pc
=> 0x8000c:     add     x0, x0, x1
(gdb) stepi

Thread 1 hit Breakpoint 3, 0x0000000000080010 in ?? ()
1: x/i $pc
=> 0x80010:     hlt     #0x0
(gdb) i reg x0 x1 x3
x0             0x5                 5
x1             0x3                 3
x3             0x81000             528384
```
x0 содержит результат сложения чисел а и b которые расположены в
памяти и были загружены в регистры x0,x1
x1 содержит число `b`
x3 содержит адрес страницы данных
Поздравляю! Мы в очередной раз сложили два числа новым способом

### Программа на ассемблере
Пример на ассемблере для иллюстрации.
данные находятся в той же секции что и код поэтому 
мы можем использовать директиву .org
код не компилировался и не проверялся.
```
	.align 2
	.section .text
_start:	
	ADRP	X3, a
	LDR	X0, [X3, #0]
	LDR	X1, [X3, #8]
	ADD 	X0,X0,X1
	HLT	#0

//Page 1 contains data. Expected physical memory address 0x81000
	.org 0x1000
a:	.dword 0x2
b:	.dword 0x3

```

### Модификация для 64-бит
Скорее всего вы обратили внимания на то что есть 4 байта между
значениями а и b по адресу 0x81004, а в ассемблерном коде
я использовал директиву резервирования двойного слова.
Двойное слово - double word в архитектуре Arm AArch64 имеет размер
64-бита. Давайте модифицируем команды загрузки для работы с числами
64-бита.
[C6.2.191 LDR (immediate)](https://developer.arm.com/documentation/ddi0602/2024-12/Base-Instructions/LDR--immediate---Load-register--immediate--?lang=en)
```
31	30	29	28	27	26	25	24	23	22	21	20	19	18	17	16	15	14	13	12	11	10	9	8	7	6	5	4	3	2	1	0
1	x	1	1	1	0	0	1	0	1	imm12												Rn					Rd				
size	      |				VR		|	opc    |	
```
загружаем первое заначение в X0
size = 11b -- что соотвествует 64 битам
imm12 = 0000 0000 0000b - первое значение находится по смещению 0 
относительно начала страницы
Rd - регистр назначения x0= 0 0000b
Rn - регистр базы x3 = 0 0011b
0000 1000 0110 0000b
-------|----||-----|
imm12    Rn    Rd
транслируем команду LDR (immediate) X0, [X3, #0]
```
60 00 40 F9
```
запишем её по смещению в файле 0x0004
для команды LDR (immediate) X1, [X3, #8]
следует скорректировать смещение imm12

size = 11b -- что соотвествует 64 битам
imm12 = 0000 0000 0001b - шаг для смещения по 8 байт 
относительно начала страницы
Rd - регистр назначения x0= 0 0000b
Rn - регистр базы x3 = 0 0011b
0000 0100 0110 0001b
-------|----||-----|
imm12    Rn    Rd
```
61 04 40 F9
```
записываем команду в файл по смещению 0x0008

```
03 00 00 B0 
60 00 40 F9 
61 04 40 F9 
00 00 01 8B 
00 00 40 D4
```
Перезапускаем эмулятор.
Проверяем в gdb. 
```
(gdb) target remote localhost:1234
(gdb) c
(gdb) stepi
0x0000000000080004 in ?? ()
1: x/i $pc
=> 0x80004:     ldr     x0, [x3]
(gdb)
```
обратите внимание на то что имя регистра изменилось на x0 - это 
говорит о том что будет загружено 64-битное значение.
```
(gdb) stepi
0x0000000000080008 in ?? ()
1: x/i $pc
=> 0x80008:     ldr     x1, [x3, #8]
(gdb)
```
Как видно `#8` указывает правильное смещение для второго числа.
выполняем `stepi` два раза, и проверяем результат
`i reg x0 x1 x3`
```
(gdb) stepi

Thread 1 hit Breakpoint 2, 0x000000000008000c in ?? ()
1: x/i $pc
=> 0x8000c:     add     x0, x0, x1
(gdb) stepi

Thread 1 hit Breakpoint 3, 0x0000000000080010 in ?? ()
1: x/i $pc
=> 0x80010:     hlt     #0x0
(gdb) i reg x0 x1 x3
x0             0x5                 5
x1             0x3                 3
x3             0x81000             528384
(gdb)
```
### Итоги примера PC-relative Page
Адресация PC-relative Page гараздо гибче PC-relative, позволяет 
адресовать пространство до 4ГБ. 

- Команда ADRP позволяет задать базу для области данных с выравниванием
на границу страницы 4КБ.
- Команда ADR позволяет задать базу относительно текущего PC. Однако,
требуются некоторые преобразования, чтобы выравнять базу на границу
страницы 4KБ
- Команда LDR позволяет работать со смещением относительно базы.
- Если переместить команду LDR по другому адресу смещение 
пересчитывать не нужно, что позволяет лекго модифицировать программу. 
Следует лишь записать смещения данных относительно начала 
страницы(базы).
- Для команды LDR aссемблер автоматически пересчитает значение 
смещения для поля imm12 в зависимости от выбраной ширины 32 или 
64 бита. 
- При ручной трансляции следует следить за выбранным размером данных.
учитывать его про расчете смещения для поля imm12
- Команда LDR имеет три режима адресации post-, pre-indexed, Unsigned
offset


## Пример 3. Базовый регистр плюс смещение
В целом, этот пример похож на пример 2. в месте загрузки
регистра хранящего значение базы, отличие в том что регистр X2
будет загружен смещением относительно базы для получения 
значения числа `b` в регистр X1. Загрузка значения в регистр X0,
происходит также как и примере 2. Указанием смещения непосредственно
в команде. Так как смещение равно 0.

### Алогоритм
В алгоритме будет добавлен один шаг - загрузка смещения.
1. Загрузить в регистр x3 адрес начала страницы данных.
2. Загрузить в регистр x2 смещение относительно _data для метки b
3. Загрузить число a в регистр x0 относительно базы с указанием 
смещения 8, метка a
4. Загрузить число b в регистр x1, относительно базы X3 + смещение
указанное в X2, т.е метка b
5. Сложить a и b результат поместить в x0
6. останов
Такой алгоритм даёт нам большую вариативность исполнения.
Мы можем использовать регистр x2 для обеих команд загрузки
x1, x0 произведя манипуляции со смещением. При помощи команд
непосрественной загрузки или арифметическими операциями.

### Программа и трансляця
Карта памяти для этого примера выглядит так:
```
Memory		Mnemonic	Address

младший адрес 0x0008 0000
v
+------------+
|00 00 00 00 |	<- 0x0008 0000-0x0008 0003 `_start`
|00 00 00 00 |	Место для команд 4Кб.Code
|00 00 00 00 |	
|....	     |  Данные расположены дальше к старшим адресам
		начиная с адреса 0x0008 1000
|00 00 00 00 |	Данные <- 0x0008 1000-0x0008 1004 `_data`, 
|00 00 00 00 |	так называемая Страница 1 относительно _start
|00 00 00 00 |			

	     ^
	     старший адрес
```
0x0008 0000 - Адрес загрузки прошивки и область для кода. Мы 
условились что эта область 4КБ. Метка _start ссылается на этот адрес.
0x0008 1000 - Мы условись располагать данные начиная с этого адреса.
Метка _data ссылается на этот адрес

В предыдущих примерах, мы располагали число `a` по адресу 
0x0008 1000. Что можно воспринимать по разному, т.к. 
метка `a` и `_data` транслируются в один адрес, и физически это
один адрес, то с точки режима PC-relative нет разници, обе метки
дадут одно и тоже смещение. Режимы Базовый регистр плюс смещение,


В этом примере мы поместим данные о первом слогаемом `a` 
со смещением 0x08 относительно метки _data, второе слогаемое
расположим с смещением 0x10, что будет соотвествовать
физическим адресам 0x0008 1008 и 0x0008 1010 соотвественно.
Смещения относительно начала файла будут
0x1008 и 0x1010 для `a`и `b` соотвественно.

Напоминаю алгоритм
1. Загрузить в регистр x3 адрес начала страницы данных.
2. Загрузить в регистр x2 смещение относительно _data для метки b
3. Загрузить число a в регистр x0 относительно базы с указанием 
смещения 8, метка a
4. Загрузить число b в регистр x1, относительно базы X3 + смещение
указанное в X2, т.е метка b
5. Сложить a и b результат поместить в x0

### Установка данных в файле
Перед трансляцией скопируйте файл TwoPageBlank.img в новый с именем
kernel8.img. Каталог 03-BaseOffset
Записываем числа `a` и `b` в файл kernel8.img
по смещению относительно файла
0x1008 0x2
0x1010 0x3

### Трансляция ADRP - установка базового регистра X3
Как и в примере 2. мы обращаемся к первой странице, где расположены данные
используем тот факт, что текущая команда имеет смещение 0x0000 относительно
текущей нулевой страницы. Нумерация страниц условная, выбраная нами 
исключительно для удобства.
```
```
[C6.2.13 ADRP]
[ADRP](https://developer.arm.com/documentation/ddi0602/2024-12/Base-Instructions/ADRP--Form-PC-relative-address-to-4KB-page-?lang=en)
```
31	30	29	28	27	26	25	24	23	22	21	20	19	18	17	16	15	14	13	12	11	10	9	8	7	6	5	4	3	2	1	0
1	immlo		1	0	0	0	0	immhi																			Rd				
op				
```
Обратите внимание что константа разбита на два поля immhi и immlo
эта константа будет умножена на 4096 -- размер страницы

immlo - младшие биты. Мы обращаемся к странице 1 соотвественно = 01b
immhi - старшие биты. Все равны нулю. 
Rd - x3 = 0 0011b 
Транслируем
```
03 00 00 B0
```
записываем команду по смещению относительно файла 0x0000

### Трансляция MOV -- установка смещения для числа `b` регистр X2
Уже знакомая команда непосредственной загрузки MOV, но с другими значениями
обратите внимание 16 указано в десятиричной форме.
```
MOV X2, #16
```
```
31	30	29	28	27	26	25	24	23	22	21	20	19	18	17	16	15	14	13	12	11	10	9	8	7	6	5	4	3	2	1	0
sf	1	0	1	0	0	1	0	1	hw		imm16														Rd					
	opc			
```
Как видим тут есть ряд полей которые надо задать перед тем как 
кодировать:
- imm16 - наша константа 16=0x10. биты 5-20 в битовом виде будет 
0000000000010000b
- sf - флаг ширины =1b : 1 -регистры x0-x30 64-битные, 0 - регистры 
w0-w30 32-битные 
- hw - биты 21-22 указывающие на сколько бит будет произведён сдвиг, 
нам это не надо поэтому 00b
- Rd - номер регистра назначения, буква d. будем грузить в X2, поэтому 
биты с 0-4 равны 0 = 00010b обратите внимание 5 бит(!)
Сложная часть, в младших битах 15-0
```
0000 0010  0000 0010
-imm16-------||-Rd-|

Hex: 02 02
```
Код команды
```
02 02 80 D2
```
Записываем в kernel8.img начиная от смещиния 0x0004

### Трансляция LDR -- база + непосредственное смещение число `a`в X0
Используем 64-bit режим, режим Unsigned Offset, прочитайте документацию
обратите вниманию на логику сдвига поля imm12 для Aach64 state

[C6.2.191 LDR (immediate)](https://developer.arm.com/documentation/ddi0602/2024-12/Base-Instructions/LDR--immediate---Load-register--immediate--?lang=en)
```
31	30	29	28	27	26	25	24	23	22	21	20	19	18	17	16	15	14	13	12	11	10	9	8	7	6	5	4	3	2	1	0
1	x	1	1	1	0	0	1	0	1	imm12												Rn					Rd				
size	      |				VR		|	opc    |	
```
загружаем  значение `a` в X0
size = 11b -- что соотвествует 64 битам
imm12 = 0000 0000 0001b - первое значение находится по смещению 0x0008
относительно начала относительно начала страницы.
imm12 сдвигается на 3 бита влево чтобы получить реальное смещение.
```
constant integer scale = UInt(size);
constant bits(64) offset = LSL(ZeroExtend(imm12, 64), scale);
```

Rd - регистр назначения x0= 0 0000b
Rn - регистр базы x3 = 0 0011b
0000 0100 0110 0000b
-------|----||-----|
imm12    Rn    Rd
транслируем команду LDR (immediate) X0, [X3, #8]
```
60 04 40 F9
```
запишем её по смещению в файле 0x0008
для команды LDR (immediate) X0, [X3, #8]
### Трансляци LDR -- база + регистр смещение, число `b` в X1
Новая команда загрузки, использует регистр хранящий базу и регистр, 
которой хранит смещения X3, X2 соотвественно.
[C6.2.193 LDR (register)](https://developer.arm.com/documentation/ddi0602/2024-12/Base-Instructions/LDR--register---Load-register--register--?lang=en) 
```
31	30	29	28	27	26	25	24	23	22	21	20	19	18	17	16	15	14	13	12	11	10	9	8	7	6	5	4	3	2	1	0
1	x	1	1	1	0	0	0	0	1	1	Rm					option			S	1	0	Rn					Rd				
size	      |				VR		|	opc    |	
```
C кодирование регистров не должно возникнуть сложностей, а вот 
с полями size, option, S стоит быть внимательными, 
В основном эти поля применяются, когда необходимо расширить регистр.
Расширить -- это значит значение было загружено в 32-разрядный регистр
а для команды требуется 64-битный. расширение можно делать с учётом 
знака или без него. Обратите внимание что в документации указаны 
разные значения полей для разных режимов работы команды, которые 
указываются в поле `size`
Итак,
size 	= 11b - Aarch64 state.
Rt	- регистр назначения X1 = 0 0001b
Rn	- регистр базы X3 = 0 0011b
Rm	- регистр индекса X2 = 0 0010b
option	-  по умолчанию используется режим LSL - логический сдвиг
	влево. 011b. Так как бит 0 в этом поле равен 1. то поле
	Rm будет принимать регистры Xn. Сейчас мы не будем 
	производить модификации над содержимым регистра 
	индекса(смещения). поэтому option=011b
S	-  на сколько бит будет произведен сдвиг
	два доступных значени 0 и 1. В нашем случаее S=1

Bсе поля для команды заданы, транслируем:
3 байт биты 23-16
```
0110 0010b
   |-Rm-|
```
1-2 байты команды биты 15-0
```
     0110 1000  0110 0001b
option-|S|  |-Rn--||-Rt-|
```

```
61 68 62 F8
```
Записываем команды по смещению 0x000C
### Трансляция ADD -- X0+X1 результат в X0   
Команда которая остается неизменная во всех примерах 
[C6.2.6 ADD (shifted register)](https://developer.arm.com/documentation/ddi0602/2024-12/Base-Instructions/ADD--shifted-register---Add-optionally-shifted-register-?lang=en)
```
31	30	29	28	27	26	25	24	23	22	21	20	19	18	17	16	15	14	13	12	11	10	9	8	7	6	5	4	3	2	1	0
sf	0	0	0	1	0	1	1	shift		0	Rm					imm6					Rn					Rd				
	op	S	
```   
Cдвигать нам не требуется поэтому:
- sf = 1b используем 64-битные регистры x0-x30
- imm6 = 00 0000b количество бит сдвига
- shift = 00b логический сдвиг влево LSL, можно выбрать любой кроме 
зарезервированного. значение 00b проще кодировать поэтому не усложняем
- Rd - x0 регистр назначения 0 0000b
- Rn - x0 первый операнд 0 0000b
- Rm - x0 второй операнд 0 0001b

```
00 00 01 8B
```
Записываем команды по смещению 0x0010
И команду HLT
```
00 00 40 D4
```
Записываем команды по смещению 0x0014
### Запуск и проверка
Проверьте что числа `a` и `b` установлены по смещению 
0x1008 и 0x1010.
переходите в каталог 03-BaseOffset, запускайте эмулятор
```
qemu-system-aarch64w -M raspi3b -s -S -kernel kernel8.img
```
Запускайте отладчик, подключитесь к эмулятору? установите точки останова
на 0x0008 0000 и 0x0008 0010, перейдите на программу.
``
target remote localhost:1234
b *0x80000
b *0x80010
continue
``
```
aarch64-none-elf-gdb
(gdb) target remote localhost:1234
Remote debugging using localhost:1234
warning: No executable has been specified and target does not support
determining executable automatically.  Try using the "file" command.
0x0000000000000000 in ?? ()
1: x/i $pc
=> 0x0: ldr     x0, 0x18
(gdb) b *0x80000
Note: breakpoint 1 also set at pc 0x80000.
Breakpoint 4 at 0x80000
(gdb) b *0x80010
Note: breakpoint 3 also set at pc 0x80010.
Breakpoint 5 at 0x80010
(gdb) continue
Continuing.

Thread 1 hit Breakpoint 1, 0x0000000000080000 in ?? ()
1: x/i $pc
=> 0x80000:     adrp    x3, 0x81000
```
загружаем в x3, адрес страницы данных - это x3 будет регистр базы
выполняем команду, просматриваем содержимое регистров x0,x1,x2,x3
```
(gdb) stepi
0x0000000000080004 in ?? ()
1: x/i $pc
=> 0x80004:     mov     x2, #0x10                       // #16
(gdb) i reg x0,x1, x2,x3
Invalid register `x0,x1,'
(gdb) i reg x0 x1  x2 x3
x0             0x100               256
x1             0x0                 0
x2             0x0                 0
x3             0x81000             528384
```
всё хорошо. X3 содержит адрес страницы данных.
Следующая команда загрузит в x2 смещение 0x16 
```
mov     x2, #0x10 
```
выполняем по шагам, и контролируем регистры
```
stepi
i reg x0 x1  x2 x3
```
```
(gdb) stepi
0x0000000000080008 in ?? ()
1: x/i $pc
=> 0x80008:     ldr     x0, [x3, #8]
(gdb) i reg x0 x1 x2 x3
x0             0x100               256
x1             0x0                 0
x2             0x10                16
x3             0x81000             528384
```
регистр X2 загружен смещением 0x10 относительно базы 0x81000, та что
находится в регистре X3. Что соотвествует адресу 0x81010
Это адрес по которому хранится число `b` давайте проверим
```
(gdb) x/32xb 0x81000
0x81000:        0x00    0x00    0x00    0x00    0x00    0x00    0x00    0x00
0x81008:        0x02    0x00    0x00    0x00    0x00    0x00    0x00    0x00
0x81010:        0x03    0x00    0x00    0x00    0x00    0x00    0x00    0x00
0x81018:        0x00    0x00    0x00    0x00    0x00    0x00    0x00    0x00
(gdb) x/8xw 0x81000 
0x81000:        0x00000000      0x00000000      0x00000002      0x00000000
0x81010:        0x00000003      0x00000000      0x00000000      0x00000000
```
Здесь указан вывод в различных представлениях 
команда
``` 
x/32xb 0x81000
```
производит вывод 8 4-байтных слов
команда
``` 
x/8xw 0x81000 
```
Вернемся к нашей следующей команде кода, проверив значения в памяти
мы сможем ожидать результат, выполним команду и проверим состояние 
регистров

```
0x80008:     ldr     x0, [x3, #8]
```

```
(gdb) stepi

Thread 1 hit Breakpoint 2, 0x000000000008000c in ?? ()
1: x/i $pc
=> 0x8000c:     ldr     x1, [x3, x2]
(gdb) i reg x0 x1 x2 x3   
x0             0x2                 2
x1             0x0                 0
x2             0x10                16
x3             0x81000             528384
```
X0 - содержит значение `a`, которое загружено из памяти по адресу
0x81008
Теперь, загрузим значение `b` База в X3+(смещение или индекс) в Х2
итоговый адрес 0x81010, выполним шаг проверим результат
```
(gdb) x /xw 0x81010
0x81010:        0x00000003
(gdb) stepi

Thread 1 hit Breakpoint 3, 0x0000000000080010 in ?? ()
1: x/i $pc
=> 0x80010:     add     x0, x0, x1
(gdb) info reg x0 x1 x2 x3
x0             0x2                 2
x1             0x3                 3
x2             0x10                16
x3             0x81000             528384
```
и наконец сложим `a` и `b` командой 
```
add     x0, x0, x1
```

```
(gdb) stepi
0x0000000000080014 in ?? ()
1: x/i $pc
=> 0x80014:     hlt     #0x0
(gdb) i reg x0 x1 x2 x3
x0             0x5                 5
x1             0x3                 3
x2             0x10                16
x3             0x81000             528384
(gdb)
```

```
x0             0x5                 5
```
Результат выполнения программы, соотвествует ожиданиям.
регистр X0 содержит сумму 2 и 3.


### Программа на ассемблере
Если сравнивать скомпилированный пример с написаной программой, то
скомпилированный пример kernel8.img.compiled  на одну команду больше.
В скомпилированном примере, вторая и третья команды идентичны
хотя произведены разными мнемониками. 
Приведены для иллюстрации работы выражений ассемблера.
Обратите внимание, что смещение расположено внутри квадратных
скобок `[X3, a-data]` этот способ указывает ассебмлеру,
что будет выбран режим адресации Base + immediate offset
если смещение вынести за скобки будет выбран другой режим адресации
pre- или post-index. Об этом подробнее в следующем примере.
```
	.align 2
	.section .text
_start:
	ADRP	X3, _data
	MOV	X2, b-_data 	/* адрес метки b больше адреса 
				базы _data */
	MOV	X2, #16 	/* для иллюстрации, что команды будут 
				идентичным */

	LDR	X0, [X3, a-data]
	LDR	X1, [X3, X2]
	ADD	X0,X0,X1
	HLT	#0
	.org 0x1000		/* так как _data находится в секции
				.text мы можем использвать директиву 
				.org чтобы задать смещение 
				относительно начала секции.
				Если бы _data находилась в другой 
				секции, то потребовалась бы 
				модификация файла link.ld				
				*/
_data:	.space 8
a:	.dword 2
b:	.dword 3

```
Сейчас я умышленно упускаю детальное описание синтакиса и дирректив 
GNU assembler.
Директивы, то что начинается с точки`.`, а метки всегда заканчиваются
двоеточием `:`.

### Итоги примера 3. Базовый регистр плюс смещение.
- Смещение для базового регистра можно задавать непосредственно в 
команде или в регистре
- Загрузку базового регистра можно произвести любым удобным способом.
- Если использовать регистр как индекс над ним можно производить
различные арифметические опереции, добиваясь нужного смещения.
- Следует внимательно следить за шириной используемых регистров
64-, 32-бита. По необходимости применять опции расширения, особенно
важно при ручной трансляции. Необходимо следить за знаковым и 
беззнаковым расширением
- Опции расширения будут автоматически применены если использовать 
ассемблер.
- Можно сказать что режим База+индекс один из основных. Его также
можно применять при работе с регистром стека SP(X30) 


## Руководства и справочники
### Youtube
- <a href="http://www.youtube.com/watch?feature=player_embedded&v=nu5z6qfLNU8
" target="_blank"><img src="http://img.youtube.com/vi/nu5z6qfLNU8/0.jpg" 
alt="Видео к упражнению 01" width="240" height="180" border="10" /></a>
- <a href="http://www.youtube.com/watch?feature=player_embedded&v=nu5z6qfLNU8
" target="_blank"><img src="http://img.youtube.com/vi/nu5z6qfLNU8/0.jpg" 
alt="Видео к упражнению 02-03" width="240" height="180" border="10" /></a>

### Cправочники
* Справочное руководство по архитектуре  [Справочник по иструкциям AArch64](https://developer.arm.com/documentation/ddi0602/2024-12/?lang=en)
* Глава из руководства Chapter C3 A64 Instruction Set Overview

Команды в примерах
- [C6.2.6 ADD (shifted register)](https://developer.arm.com/documentation/ddi0602/2024-12/Base-Instructions/ADD--shifted-register---Add-optionally-shifted-register-?lang=en)
- [C6.2.13 ADRP](https://developer.arm.com/documentation/ddi0602/2024-12/Base-Instructions/ADRP--Form-PC-relative-address-to-4KB-page-?lang=en)
- [C6.2.191 LDR (immediate)](https://developer.arm.com/documentation/ddi0602/2024-12/Base-Instructions/LDR--immediate---Load-register--immediate--?lang=en) 
- [C6.2.192 LDR (literal)](https://developer.arm.com/documentation/ddi0602/2024-12/Base-Instructions/LDR--literal---Load-register--literal--?lang=en)
- [C6.2.193 LDR (register)](https://developer.arm.com/documentation/ddi0602/2024-12/Base-Instructions/LDR--register---Load-register--register--?lang=en)
### Команды gdb
запуск gdb 
```
aarch64-none-elf-gdb
```
Использованые команды gdb
```
set architecture
Просмотр информации о регистрах
info reg
i reg x0
i reg x1
i reg x0 x1 x2 x3
Просмотр информации в памяти
x 0x81080
x 0x81010
x /32xb 0x81000
x /8xw 0x81000

display /i $pc
display /i $x0

target remote localhost:1234
Управление исполнением
stepi
c
continue
Точки останова
b *0x80000
b *0x8000C
