# Два плюс Два в памяти
## Ссылки и инструменты
### Инструменты
* Эмулятор [QEMU для window 64](https://qemu.weilnetz.de/w64/)
* Компилятор, сборщик, отладчик [Aarch64 GNU compiler collection](https://developer.arm.com/downloads/-/arm-gnu-toolchain-downloads)
* Отладчик gdb


## Цели, задачи
Цель предыдущего упражнения была познакомить с принципом ручной 
трансляции. Это упражнение направлено изучения основ работы с памятью
Как и в первом упражнении вам не потребуется специфических знаний
об инструментах, таких как ассемблер или линковщик, только 
документация по платформе, и знание небольшого количества фактов, 
которые уже вам известны из первого упражнения. В этом упражнении мы 
также применим ручную трансляцию, только разбирать её подробно 
не будем, ограничимся обозначением команды, и описанием полей.
Мы сделаем пять примеров адресации памяти:
* относительно PC(Program Counter)
* относительно PC c выравниванием на 4K - страница
* Базовый регистр плюс смещение
* Пре-индексная
* Пост-индексная

В этих примерах я не буду останавливаться на различных типах данных, 
предлагаю вам попробовать самостоятельно.

### Зачем работать с памятью, я тут на констанах всё могу посчитать.
В первом примере мы использовали констаны непосрественно 
закодинованные в команду, используя команду MOV(wide immediate) 
из группу Data processing - immediate
такой способ имеет ограничения:
- значения констант 0-65535, обусловленно длинной поля 16 бит
- отсутствие возможности изменять входные значения, потребуеться 
повторная трансляция при новых входных значениях. В этом упражнении,
мы попробуем работать с "большими" числами.

Входные данные и выходные должны находится в памяти потому что
подавляющеей большинство команд устроены так. К слову 
сказать регистры процессора это тоже память  --- регистровая.

Для загрузки и сохранения значений из оперативной памяти в регистры PE
(processing element), по простому процессор, а точнее ядро процессора,
предназначена группа команд Loads and Stores (Загрузка и Сохранение) 
[C3.2 Loads and Stores]

Существует несколько способов указать адрес в памяти:
Секция [C3.2/1 Load/store register] перечисляет доступные режимы 
адресации 
- Только Базовый регистр
- Базовый регистр плюс смещение
- Пред-индексированный
- Пост- индексированый
- Относительно PC 

Мы рассмотрим на примерах ниже, каждый из этих режимов.
Более подробно о режимах адрессации [C1.3.3 Load/store addressing modes]

### Алгоритм 
Напомню алгоритм, который мы используем в прмерах
1. Загрузить число a в регистр x0
2. Загрузить число b в регистр x1
3. Сложить a и b результат поместить в x0

Это всё теория, перейдем к практике
## Пример 1. Относительно PC
Code\01-PCRelative 
Это самый простой для понимания, и сложный для исполнения пример.
### Алгоритм 
Напомню алгоритм, который мы используем в прмерах
1. Загрузить число a в регистр x0
2. Загрузить число b в регистр x1
3. Сложить a и b результат поместить в x0
4. останов
Итак, наша программа выглядит не больше 4
четырех команд. Если мы поместим данные сразу за командой HLT, 
то каждый раз на придется "двигать" область памяти предназначеную 
для данных и каждый раз пересчитывать смещиние. О чем это я?
Каждая команда это 32 бита 4 байта. Программа из примера с 
константами в памят выглядит 
```
Memory		Mnemonic	Address

младший адрес 0x0008 0000
v
+------------+
|40 00 80 D2 |	MOV X0, #2	<- 0x0008 0000-0x0008 0003
|41 00 80 D2 |	MOV X1, #2	<- 0x0008 0004-0x0008 0007
|00 00 01 8B |	ADD X0,X0,X1	<- 0x0008 0008-0x0008 000B
|00 00 40 D4 |	HLT		<- 0x0008 000C-0x0008 000F
|...
	     ^
	     старший адрес
```
Давайте предположим что мы расширим эту программу до 8 команд.
И расположим данны начиная с адреса 0x0008 0020. Оставим пока
код программы не изменным нас интересуют данные.
```
Memory		Mnemonic	Address

младший адрес 0x0008 0000
v
+------------+
|40 00 80 D2 |	MOV X0, #2	<- 0x0008 0000-0x0008 0003
|41 00 80 D2 |	MOV X1, #2	<- 0x0008 0004-0x0008 0007
|00 00 01 8B |	ADD X0,X0,X1	<- 0x0008 0008-0x0008 000B
|00 00 40 D4 |	HLT		<- 0x0008 000C-0x0008 000F
|00 00 00 00 |	----------
|00 00 00 00 |	Место по дополнителных команд
|00 00 00 00 |
|00 00 00 00 |	----------	<- 0x0008 001C-0x0008 001F
|02 00 00 00 |	Число a		<- 0x0008 0020-0x0008 0023	
|00 00 00 00 |
|02 00 00 00 |			<- 0x0008 0028-0x0008 002B
|00 00 00 00 |	Число b
|  ...	
	     ^
	     старший адрес
```
Запишим адреса наших меток
a: 0x0008 0020
b: 0x0008 0028

В этом момент, у вас должен начать ломаться мозг. 
Обратите внимание, что под а и b выделенно по 64-бита(8 байт)
Давайте попробуем загрузить числа в соотвествющие регистры
Используя адресацию относительно PC(Program Counter)
Первая команда исполняется по адресу 0x0008 0000
проверьте ещё раз раздел [C3.2.1 Load/store register]
И из таблици подберите команду с необходимой адресацией -- 
Load register (PC-relative literal)
[C6.2.192 LDR (literal)]
[LDR (literal)](https://developer.arm.com/documentation/ddi0602/2024-12/Base-Instructions/LDR--literal---Load-register--literal--?lang=en)
```
31	30	29	28	27	26	25	24	23	22	21	20	19	18	17	16	15	14	13	12	11	10	9	8	7	6	5	4	3	2	1	0
0	1	0	1	1	0	0	0	imm19																			Rt				
	op				VR
```
- imm19 - относительное смещение c знаком = 000  0000 0000  0000 1000b
- Rt - регистр назначения x0 = 00000b

imm19 19бит смещение относительно текущего PC. для первой команды 
PC равен 80000, число `а` находится по адресу 80020, следовательно 
смещение будет равно 0x20 = 0010 0000b. Следует помнить что смещение может быть 
и отрицательным. Отрицательные числа представляются в формате Two's 
complamentary addition - дополнение до двойки, или второе 
компламентарное дополнение.

Внимательно читаем документацию, оносительное смещение имеет 
ограничение +-1МБ, а это 20 бит и плюс один бит на знак
Однако, в команде  константа шириной 19-bit, которая принципиально
не способна адресовать 1МБ. Обратите внимание что константа сдвигается
влево на 2 бита, т.е умножается на 4. Что означает, что данные должны 
быть выровнены на границу слова(word) 4 байт или 32 бит.
поэтому, значение необходимого смещения 0x20 сдвигаем влево на 2 бита
и уменьшено до 0x08 = 0000 1000b

### Первая команда  LDR X0, a
Итак наша команда будет выглядеть вот так
LDR X0, a
```
00 01 00 58
```
Сложность в трансляции преставляют младшие байты
```
0000 0001 0000 0000
------------||----|
imm19		Rt
```

### Вторая команда  LDR X1, b
Используем команду LDR для загрузки второй константы.
Следует помнить что адрес второй команды уже 0x0008 0004
а число по метке `b`на ходится по адресу 0x0008 0028
соотвественно смещение будет 0x24 = 0010 0100b
приготовим констану imm19, сдвинув смещение на 2 бита вправо
imm19 = 0000 1001b
Данные для трансляции:
imm19 = 000  0000 0000  0000 1001b
Rt - регистр назначения x1 = 0 0001b
LDR X1, b
```
21 01 00 58
```
```
0000 0001 0010 0001
------------||----|
imm19		Rt
```
### Программа на языке ассемблера 
ассемблер в синтаксесе GNU. Пример не полный так как 
к необходим файл для линковки. Иструменты и линковка отдельная тема
Здесь приведен код в качестве иллюстрации.
```
	.align 2
	.section .text
_start:	
	LDR X0, a
	LDR X1, b
	ADD X0,X0,X1
	HLT
.space 8 , 0x00
a:
	.word 0x2
	.word 0x0
b:	
	.word 0x2
	.word 0x0
```

### Программа в машинном коде
как и прошлом примере создайм  файл в Hex редакторе
kerne8.img и переносим данные
```
00 00 00 58 
21 01 00 58
00 00 01 8B 
00 00 40 D4
00 00 00 00 
00 00 00 00
00 00 00 00 
00 00 00 00
02 00 00 00 
00 00 00 00
02 00 00 00 
00 00 00 00
```
### Запуск и проверка
закройте эмулятор если он у вас открыт, и запустите новое окно с 
обновлённым файлом kernel8.img из каталога Code\01-PCRelative
```
 qemu-system-aarch64w -M raspi3b -s -S -kernel kernel8.img
```
Запустим отладчик
```
aarch64-none-elf-gdb
```
В отладчике установим точки останова по адресам 0x80000, 0x8000C
все следующие действия выполняем в окне отладчика
```
b *0x80000
b *0x8000C
```
Настроим отображение текущей команды и значение счетчика команд
```
display /i $pc
```
Подключаемся к эмулятору и запускаем прошивку на исполнение
```
(gdb)target remote localhost:1234
(gdb))continue
```
Следует ожидать вывода
```
Thread 1 hit Breakpoint 1, 0x0000000000080000 in ?? ()
1: x/i $pc
=> 0x80000:     ldr     x0, 0x80020
(gdb)
```
Как видим gdb сделал остановку по адресу  0x0000000000080000
и первая команда загрузит регистр x0 значением из памяти по адресу
0x80020.
Давайте проверим значение какое значение храниться по адресу 0x80020
```
(gdb) x 0x80020
0x80020:        0x00000002
```
Все верно, теперь выполним первую команду `stepi` и проверим значение по 
которое будет использовано для второй команды.
```
(gdb) stepi
0x0000000000080004 in ?? ()
1: x/i $pc
=> 0x80004:     ldr     x1, 0x80028
```
Сначала проверим какое значение хранится в регистре x0
команда gdb - i reg x0 
и значение числа b находится по адресу 0x80028
команда gdb - x 0x80028
```
(gdb) i reg x0
x0             0x2                 2
(gdb) x 0x80028
0x80028:        0x00000002
```
Все правильно.
Давайте выполним две команды подряд --
1. загрузка значения в x1
2. сложение x0 и x1 с результатом в x0
два раза выполните команду `stepi` в gdb
```
(gdb) stepi
0x0000000000080008 in ?? ()
1: x/i $pc
=> 0x80008:     add     x0, x0, x1

(gdb) stepi
Thread 1 hit Breakpoint 2, 0x000000000008000c in ?? ()
1: x/i $pc
=> 0x8000c:     hlt     #0x0
```
командой `i reg x0` проверим результат работы программы
```
(gdb) i reg x0
x0             0x4                 4
```
Все верно x0 содержит 4 -- результат сложения x0, x1. И у нас есть
персональный сумматор способный работать с 32-битными значениями.
Вы может поэкспериментировать со значениями по смещениям 0x20 и 
0x28 в файле kernel8.img

### Итоги первого примера
PC-relative простой способ загрузить значения из памяти в регистр,
но у него есть существенные ограничения, а именно:
- значения должны располагатся относительно текущей команты +- 
1Мбайт(20бит)
- Как только изменяется программа, необходимо пересчитывать смещение
относительно команды
Из плюсов для небольших программ, и с простой схемой расположения -
по фиксированным адресам, вычислить адрес относительно просто.


Loads and stores
Data processing - immediate
Data processing - register


 Data processing - register
 • Arithmetic (shifted register). [ADD, ADDS, SUB, SUBS, CMP,
  CMN, NEG, NEGS]
 • Move (register). [ MOV ]

## Руководства и справочники
* Справочное руководство по архитектуре  [Справочник по иструкциям AArch64](https://developer.arm.com/documentation/ddi0602/2024-12/?lang=en)
* Глава из руководства Chapter C3 A64 Instruction Set Overview

### Команды gdb
запуск gdb 
```
 aarch64-none-elf-gdb
```
Использованые команды gdb
```
set architecture
b *0x80000
b *0x8000C
info reg
i reg x0
i reg x1
x 0x80020
x 0x80028
display /i $pc
display /i $x0
stepi
target remote localhost:1234
c
continue

