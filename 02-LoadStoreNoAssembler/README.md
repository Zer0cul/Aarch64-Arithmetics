# Два плюс Два в памяти
## Ссылки и инструменты
### Инструменты
* Эмулятор [QEMU для window 64](https://qemu.weilnetz.de/w64/)
* Компилятор, сборщик, отладчик [Aarch64 GNU compiler collection](https://developer.arm.com/downloads/-/arm-gnu-toolchain-downloads)
* Отладчик gdb


## Цели, задачи
Цель предыдущего упражнения была познакомить с принципом ручной 
трансляции. Это упражнение направлено изучения основ работы с памятью
Как и в первом упражнении вам не потребуется специфических знаний
об инструментах, таких как ассемблер или линковщик, только 
документация по платформе, и знание небольшого количества фактов, 
которые уже вам известны из первого упражнения. В этом упражнении мы 
также применим ручную трансляцию, только разбирать её подробно 
не будем, ограничимся обозначением команды, и описанием полей.
Мы сделаем пять примеров адресации памяти:
* относительно PC(Program Counter)
* относительно PC c выравниванием на 4K - страница
* Базовый регистр плюс смещение
* Пре-индексная
* Пост-индексная

В этих примерах я не буду останавливаться на различных типах данных, 
предлагаю вам попробовать самостоятельно.

### Зачем работать с памятью, я тут на констанах всё могу посчитать.
В первом примере мы использовали констаны непосрественно 
закодинованные в команду, используя команду MOV(wide immediate) 
из группу Data processing - immediate
такой способ имеет ограничения:
- значения констант 0-65535, обусловленно длинной поля 16 бит
- отсутствие возможности изменять входные значения, потребуеться 
повторная трансляция при новых входных значениях. В этом упражнении,
мы попробуем работать с "большими" числами.

Входные данные и выходные должны находится в памяти потому что
подавляющеей большинство команд устроены так. К слову 
сказать регистры процессора это тоже память  --- регистровая.

Для загрузки и сохранения значений из оперативной памяти в регистры PE
(processing element), по простому процессор, а точнее ядро процессора,
предназначена группа команд Loads and Stores (Загрузка и Сохранение) 
[C3.2 Loads and Stores]

Существует несколько способов указать адрес в памяти:
Секция [C3.2/1 Load/store register] перечисляет доступные режимы 
адресации 
- Только Базовый регистр
- Базовый регистр плюс смещение
- Пред-индексированный
- Пост- индексированый
- Относительно PC 

Мы рассмотрим на примерах ниже, каждый из этих режимов.
Более подробно о режимах адрессации [C1.3.3 Load/store addressing modes]

### Алгоритм 
Напомню алгоритм, который мы используем в прмерах
1. Загрузить число a в регистр x0
2. Загрузить число b в регистр x1
3. Сложить a и b результат поместить в x0

Это всё теория, перейдем к практике
## Пример 1. Относительно PC
Code\01-PCRelative 
Это самый простой для понимания, и сложный для исполнения пример.
### Алгоритм 
Напомню алгоритм, который мы используем в прмерах
1. Загрузить число a в регистр x0
2. Загрузить число b в регистр x1
3. Сложить a и b результат поместить в x0
4. останов
Итак, наша программа выглядит не больше 4
четырех команд. Если мы поместим данные сразу за командой HLT, 
то каждый раз на придется "двигать" область памяти предназначеную 
для данных и каждый раз пересчитывать смещиние. О чем это я?
Каждая команда это 32 бита 4 байта. Программа из примера с 
константами в памят выглядит 
```
Memory		Mnemonic	Address

младший адрес 0x0008 0000
v
+------------+
|40 00 80 D2 |	MOV X0, #2	<- 0x0008 0000-0x0008 0003
|41 00 80 D2 |	MOV X1, #2	<- 0x0008 0004-0x0008 0007
|00 00 01 8B |	ADD X0,X0,X1	<- 0x0008 0008-0x0008 000B
|00 00 40 D4 |	HLT		<- 0x0008 000C-0x0008 000F
|...
	     ^
	     старший адрес
```
Давайте предположим что мы расширим эту программу до 8 команд.
И расположим данны начиная с адреса 0x0008 0020. Оставим пока
код программы не изменным нас интересуют данные.
```
Memory		Mnemonic	Address

младший адрес 0x0008 0000
v
+------------+
|40 00 80 D2 |	MOV X0, #2	<- 0x0008 0000-0x0008 0003
|41 00 80 D2 |	MOV X1, #2	<- 0x0008 0004-0x0008 0007
|00 00 01 8B |	ADD X0,X0,X1	<- 0x0008 0008-0x0008 000B
|00 00 40 D4 |	HLT		<- 0x0008 000C-0x0008 000F
|00 00 00 00 |	----------
|00 00 00 00 |	Место по дополнителных команд
|00 00 00 00 |
|00 00 00 00 |	----------	<- 0x0008 001C-0x0008 001F
|02 00 00 00 |	Число a		<- 0x0008 0020-0x0008 0023	
|00 00 00 00 |
|02 00 00 00 |			<- 0x0008 0028-0x0008 002B
|00 00 00 00 |	Число b
|  ...	
	     ^
	     старший адрес
```
Запишим адреса наших меток
a: 0x0008 0020
b: 0x0008 0028

В этом момент, у вас должен начать ломаться мозг. 
Обратите внимание, что под а и b выделенно по 64-бита(8 байт)
Давайте попробуем загрузить числа в соотвествющие регистры
Используя адресацию относительно PC(Program Counter)
Первая команда исполняется по адресу 0x0008 0000
проверьте ещё раз раздел [C3.2.1 Load/store register]
И из таблици подберите команду с необходимой адресацией -- 
Load register (PC-relative literal)
[C6.2.192 LDR (literal)]
[LDR (literal)](https://developer.arm.com/documentation/ddi0602/2024-12/Base-Instructions/LDR--literal---Load-register--literal--?lang=en)
```
31	30	29	28	27	26	25	24	23	22	21	20	19	18	17	16	15	14	13	12	11	10	9	8	7	6	5	4	3	2	1	0
0	1	0	1	1	0	0	0	imm19																			Rt				
	op				VR
```
- imm19 - относительное смещение c знаком = 000  0000 0000  0000 1000b = 0x08
- Rt - регистр назначения x0 = 0 0000b

imm19 19бит смещение относительно текущего PC. для первой команды 
PC равен 80000, число `а` находится по адресу 80020, следовательно 
смещение будет равно 0x20 = 0010 0000b. Следует помнить что смещение может быть 
и отрицательным. Отрицательные числа представляются в формате Two's 
complamentary addition - дополнение до двойки, или второе 
компламентарное дополнение.

Внимательно читаем документацию, оносительное смещение имеет 
ограничение +-1МБ, а это 20 бит и плюс один бит на знак
Однако, в команде  константа шириной 19-bit, которая принципиально
не способна адресовать 1МБ. Обратите внимание что константа сдвигается
влево на 2 бита, т.е умножается на 4. Что означает, что данные должны 
быть выровнены на границу слова(word) 4 байт или 32 бит.
поэтому, значение необходимого смещения 0x20 сдвигаем влево на 2 бита
и уменьшено до 0x08 = 0000 1000b

### Первая команда  LDR X0, a
Итак наша команда будет выглядеть вот так
LDR X0, a
```
00 01 00 58
```
Сложность в трансляции преставляют младшие байты
```
0000 0001 0000 0000
------------||----|
imm19		Rt
```

### Вторая команда  LDR X1, b
Используем команду LDR для загрузки второй константы.
Следует помнить что адрес второй команды уже 0x0008 0004
а число по метке `b`на ходится по адресу 0x0008 0028
соотвественно смещение будет 0x24 = 0010 0100b
приготовим констану imm19, сдвинув смещение на 2 бита вправо
imm19 = 0000 1001b
Данные для трансляции:
imm19 = 000  0000 0000  0000 1001b
Rt - регистр назначения x1 = 0 0001b
LDR X1, b
```
21 01 00 58
```
```
0000 0001 0010 0001
------------||----|
imm19		Rt
```
### Программа на языке ассемблера 
ассемблер в синтаксесе GNU. Пример не полный так как 
к необходим файл для линковки. Иструменты и линковка отдельная тема
Здесь приведен код в качестве иллюстрации.
```
	.align 2
	.section .text
_start:	
	LDR X0, a
	LDR X1, b
	ADD X0,X0,X1
	HLT
.space 16 , 0x00
a:
	.word 0x2
	.word 0x0
b:	
	.word 0x2
	.word 0x0
```

### Программа в машинном коде
как и прошлом примере создайм  файл в Hex редакторе
kerne8.img и переносим данные
```
00 01 00 58 
21 01 00 58
00 00 01 8B 
00 00 40 D4
00 00 00 00 
00 00 00 00
00 00 00 00 
00 00 00 00
02 00 00 00 
00 00 00 00
02 00 00 00 
00 00 00 00
```
### Запуск и проверка
закройте эмулятор если он у вас открыт, и запустите новое окно с 
обновлённым файлом kernel8.img из каталога Code\01-PCRelative
```
 qemu-system-aarch64w -M raspi3b -s -S -kernel kernel8.img
```
Запустим отладчик
```
aarch64-none-elf-gdb
```
В отладчике установим точки останова по адресам 0x80000, 0x8000C
все следующие действия выполняем в окне отладчика
```
b *0x80000
b *0x8000C
```
Настроим отображение текущей команды и значение счетчика команд
```
display /i $pc
```
Подключаемся к эмулятору и запускаем прошивку на исполнение
```
(gdb)target remote localhost:1234
(gdb))continue
```
Следует ожидать вывода
```
Thread 1 hit Breakpoint 1, 0x0000000000080000 in ?? ()
1: x/i $pc
=> 0x80000:     ldr     x0, 0x80020
(gdb)
```
Как видим gdb сделал остановку по адресу  0x0000000000080000
и первая команда загрузит регистр x0 значением из памяти по адресу
0x80020.
Давайте проверим значение какое значение храниться по адресу 0x80020
```
(gdb) x 0x80020
0x80020:        0x00000002
```
Все верно, теперь выполним первую команду `stepi` и проверим значение по 
которое будет использовано для второй команды.
```
(gdb) stepi
0x0000000000080004 in ?? ()
1: x/i $pc
=> 0x80004:     ldr     x1, 0x80028
```
Сначала проверим какое значение хранится в регистре x0
команда gdb - i reg x0 
и значение числа b находится по адресу 0x80028
команда gdb - x 0x80028
```
(gdb) i reg x0
x0             0x2                 2
(gdb) x 0x80028
0x80028:        0x00000002
```
Все правильно.
Давайте выполним две команды подряд --
1. загрузка значения в x1
2. сложение x0 и x1 с результатом в x0
два раза выполните команду `stepi` в gdb
```
(gdb) stepi
0x0000000000080008 in ?? ()
1: x/i $pc
=> 0x80008:     add     x0, x0, x1

(gdb) stepi
Thread 1 hit Breakpoint 2, 0x000000000008000c in ?? ()
1: x/i $pc
=> 0x8000c:     hlt     #0x0
```
командой `i reg x0` проверим результат работы программы
```
(gdb) i reg x0
x0             0x4                 4
```
Все верно x0 содержит 4 -- результат сложения x0, x1. И у нас есть
персональный сумматор способный работать с 32-битными значениями.
Вы может поэкспериментировать со значениями по смещениям 0x20 и 
0x28 в файле kernel8.img

### Итоги первого примера
PC-relative простой способ загрузить значения из памяти в регистр,
но у него есть существенные ограничения, а именно:
- значения должны располагатся относительно текущей команты +- 
1Мбайт(20бит)
- Как только изменяется программа, необходимо пересчитывать смещение
относительно команды
Из плюсов для небольших программ, и с простой схемой расположения -
по фиксированным адресам, вычислить адрес относительно просто.

## Пример 2. Относительно PC с выравниванием на 4К
В этом примере будет несколько новых концепций, команд, и программных
трюков. Этот пример послужит основой для следующих упражнений.

Перед тем как начать создайте файл размером 8Кбайт заполненый нулями.
В папке Code\02-PCRalativePage файл TwoPageBlank.img сделайте его 
копию с именем kernel8.img

На этот раз мы расположим данные "дальше" в памяти. К ним всё ещё 
можно будет обратиться способом указаном в прмере выше, просто 
представьте что код у нас занимает на четыре команды, а 4 мегабайта.
В таком случае обращение с помощью PC-relative станет невозможным.

Итак, карта памяти для текущего примера выглядит следующим образом:
```
Memory		Mnemonic	Address

младший адрес 0x0008 0000
v
+------------+
|40 00 80 D2 |	MOV X0, #2	<- 0x0008 0000-0x0008 0003
|41 00 80 D2 |	MOV X1, #2	<- 0x0008 0004-0x0008 0007
|00 00 01 8B |	ADD X0,X0,X1	<- 0x0008 0008-0x0008 000B
|00 00 40 D4 |	HLT		<- 0x0008 000C-0x0008 000F
|00 00 00 00 |	----------	<- 0x0008 0010-0x0008 0013
|00 00 00 00 |	Место по дополнителных команд 4Кб
|...	     |
|...         |	----------	
|02 00 00 00 |	Число a		<- 0x0008 1000 Начало страницы 1 Отн. смещение 0x0000	
|00 00 00 00 |				
|02 00 00 00 |	Число b		<- 0x0008 1008 Смещение относительно начала страницы 1 = 0x0008
|00 00 00 00 |			
|  ...	
	     ^
	     старший адрес
```
Обратите внимание что адреса чисел а и b изменились
на 0x0008 1000 и 0x0008 1008 соотвественно.
4Kб - это страница(page). В этом примере условимся, что код у нас 
находится на странице 0, а данные на странице 1. Физические 
адреса остаются не изменные. Деление на страницы всего лишь наше
логическое представление. И тем не менее адреса начала страниц 
подчиняются строгим правилам --выровнены на 12 бит. 
Т.е. страница не может начинаться с адреса 0x98001, но 0x98000 вполне 
допустим. В адресе начала страници должны быть последние три нуля.

4Кбайта много это или мало. По современным меркам это мало, однако
80x25 монохромный экран это чуть меньше 2 Кбайт, печатная страница 
около 4 килобайт. До этого момента размер этого файла 19Кбайт, 
но надо учитывать что кирилица это 2байта на символ в кодировке UTF-8,
в другой кодировке этот текст займёт около 8Кбайт, размер размер
можно соотнести с файлом, который мы создали в начале упражнения.

Итак, имеем две логические страницы:
- Page 0 по адресу 0x0008 0000 - код программы
- Page 1 по адресу 0x0008 1000 - данные

Чтобы упростить программу мы используем трюк и знание о том что 
первая команда выполняется по адресу 0x0008 0000  
из раздела Data processing - immediate [C3.5.6 PC-relative address
 calculation] 
нам потребуется команда ADRP

### Алгоритм 

1. Загрузить в регистр x3 адрес начала страницы данных.
2. Загрузить число a в регистр x0
3. Загрузить число b в регистр x1
4. Сложить a и b результат поместить в x0
4. останов
### Программа
Нам потребуется дополнительный регистр для хранения адреса начала 
страницы и другие команды для загрузки данных используя этот адрес страницы.
В первом варианте мы будем работать с 32-битными значениями,
Потом мы внесем изменения для работы 64-битными значениями.

[C6.2.13 ADRP]
[ADRP](https://developer.arm.com/documentation/ddi0602/2024-12/Base-Instructions/ADRP--Form-PC-relative-address-to-4KB-page-?lang=en)
```
31	30	29	28	27	26	25	24	23	22	21	20	19	18	17	16	15	14	13	12	11	10	9	8	7	6	5	4	3	2	1	0
1	immlo		1	0	0	0	0	immhi																			Rd				
op				
```
Обратите внимание что константа разбита на два поля immhi и immlo
эта константа будет умножена на 4096 -- размер страницы

immlo - младшие биты. Мы обращаемся к странице 1 соотвественно = 01b
immhi - старшие биты. Все равны нулю. 
Rd - x3 = 0 0011b 
Транслируем
```
03 00 00 B0
```

Для загрузки значений в регистры x0, x1 будем использовать команду
LDR (immediate) c режимом адресации
Base plus a scaled 12-bit unsigned immediate offset or 
base plus an unscaled 9-bit signed immediate offset.
База плюс маштабируемый 12-битное без знаковое смещение 
непосредственно в команде или
База плюс масштабируемое 9-битовое знаковое смещение непосредственно
в команде.

Давайте разберем База плюс масштабируемое 12-битное смещение.

Команда LDR (immediate) имеет три режима адресации, которые выбираются
битами 24, 10 и 11.
Эта команда может загружать 32-битные значения или 64-битные значения.
поле size отвечает за выбор ширины данных.   
Сейчас мы работаем с режимом Unsigned offset, 10 11 используются как 
младшие биты поля imm12. За выбор режима отвечает 24 бит, при 1 режим 
unsigned offset при 0 режим post- или pre-indexed и биты 10,11 
отвечают за выбор post или pre.

В документации более детально описан алгоритм, если изложить простым
языком для поля size=10b (32-битные значение) смещение imm12 будет 
указывать на каждые 4 байта, относительно базы. для поля size=11b 
(64-битные значения) смещение imm12 будет будет указывать на каждые
8 байт. Если вы не поняли ничего страшного в конце мы сделаем 
модификации, которые должны внести ясность.
Сейчас мы работаем с 32-битными значениями.

[C6.2.191 LDR (immediate)](https://developer.arm.com/documentation/ddi0602/2024-12/Base-Instructions/LDR--immediate---Load-register--immediate--?lang=en)
```
31	30	29	28	27	26	25	24	23	22	21	20	19	18	17	16	15	14	13	12	11	10	9	8	7	6	5	4	3	2	1	0
1	x	1	1	1	0	0	1	0	1	imm12												Rn					Rd				
size	      |				VR		|	opc    |	
```
загружаем первое заначение в X0
size = 10b
imm12 = 0000 0000 0000b - первое значение находится по смещению 0 
относительно начала страницы
Rd - регистр назначения x0= 0 0000b
Rn - регистр базы x3 = 0 0011b
0000 1000 0110 0000b
-------|----||-----|
imm12    Rn    Rd
транслируем команду LDR (immediate) X0, [X3, #0]
```
60 00 40 B9
```
Записываем команды начиная со смещения в файле 0x0004
Записываем число 2 `а` начиная со смещения в файле 0x1000
Записываем число 3 `b` начиная со смещения в файле 0x1008
Будьте внимательны!

```
Memory		Mnemonic	Address

младший адрес **0x0008 1000**
v
|            |	----------	
|02 00 00 00 |	Число a		<- 0x0008 1000 Начало страницы 1 Отн. смещение 0x0000	
|00 00 00 00 |				
|03 00 00 00 |	Число b		<- 0x0008 1008 Смещение относительно начала страницы 1 = 0x0008
|00 00 00 00 |			
|  ...	
	     ^
	     старший адрес
```

Теперь сделаем трансляцию команды LDR(immediate), которая загружает 
значение в регистр x1
поля для команды
size = 10b
imm12 = 0000 0000 0010b - первое значение находится по смещению 0 
относительно начала страницы
Rd - регистр назначения x0= 0 0001b
Rn - регистр базы x3 = 0 0011b

Обратите внимание, что imm12=0x2, а не 8. Это из-за логики работы 
команды, как указывалось выше смещение отсчитывает по 4байта.
При выполнении команды смещение будет автоматически сдвинуто влево
на количество бит указаных в поле размер, т.е на 2 что соотвествует
умножению на 4. Таким образом во время исполнения команда вычислит 
правильное смещение X3+8, что соотвествует адресу нашего числа `b`.
Траслируем LDR	X1, [X3, #2]
[C6.2.191 LDR (immediate)](https://developer.arm.com/documentation/ddi0602/2024-12/Base-Instructions/LDR--immediate---Load-register--immediate--?lang=en)
```
31	30	29	28	27	26	25	24	23	22	21	20	19	18	17	16	15	14	13	12	11	10	9	8	7	6	5	4	3	2	1	0
1	x	1	1	1	0	0	1	0	1	imm12												Rn					Rd				
size	      |				VR		|	opc    |	
```
Внимательно, с младшими байтами
0000 1000 0110 0001b
-------|----||-----|
imm12    Rn    Rd

```
61 08 40 B9
```
Результат трансляции записываем по смещению 0x0008 в файле
записываем уже знакомы команды
```
00 00 01 8B 
00 00 40 D4
```
по смещениям 0x000C и 0x0010 соотвественно
```
Memory		Mnemonic	Address

младший адрес 0x0008 0000
v
+------------+
|03 00 00 B0 |	ADRP X3, a		<- 0x0008 0000-0x0008 0003
|60 00 40 B9 |	LDR  X0, [X3, #0]	<- 0x0008 0004-0x0008 0007
|61 08 40 B9 |	LDR  X1, [X3, #2]	<- 0x0008 0008-0x0008 000B
|00 00 01 8B |	ADD  X0,X0,X1		<- 0x0008 000C-0x0008 000F
|00 00 40 D4 |	HLT			<- 0x0008 0010-0x0008 0013
|00 00 00 00 |	Место по дополнителных команд 4Кб
|....	     |  Данные расположены дальше к старшим адресам
		начиная с адреса 0x0008 1000

	     ^
	     старший адрес


```
Проверьте что в установили данные по смещению в файле
0x0100 и 0x0108
### Проверка 32-разрядного результата.
Запускаем gdb
```

```
перед запуском эмулятора убедитесь в правильности каталога
02-LoadStoreNoAssembler\Code\02-PCRelativePage
Запускаем эмулятор
```
qemu-system-aarch64w -M raspi3b -s -S -kernel kernel8.img
```
в gdb необходимо добавить точку останова по адресу 0x80010
и выполните подключение к эмулятору
```
(gdb) b *0x80010
Breakpoint 3 at 0x80010
(gdb) target remote localhost:1234
```
Запускаем эмулятор до первой точки останова по адресу 0x80000
```
Thread 1 hit Breakpoint 1, 0x0000000000080000 in ?? ()
1: x/i $pc
=> 0x80000:     adrp    x3, 0x81000
```
Видим правильный адрес первой страницы 0x81000, Страница, где 
расположены данные. Выполняем шаг и проверяем значение регистра x3

```
(gdb) stepi
0x0000000000080004 in ?? ()
1: x/i $pc
=> 0x80004:     ldr     w0, [x3]
(gdb) i reg x3
x3             0x81000             528384
```
Регистр x3 содержит правильное значение.
Как видите gdb дизассемблировал команду на ширину 32-бита, поэтому
название регистра заменено на w0, для сокращения imm равно 0, 
также не указано.
Проверяем наличие значений по адресам 0x81000 и 0x81008
и выполняем команду на загрузку значения в регистр x0
```
(gdb) x 0x81000
0x81000:        0x00000002
(gdb) x 0x81008
0x81008:        0x00000003
(gdb) stepi
0x0000000000080008 in ?? ()
1: x/i $pc
=> 0x80008:     ldr     w1, [x3, #8]
(gdb) i reg x0
x0             0x2                 2
```
Значения находятся на местах, в регистр x0.
Обратите внимание на команду, точнее на значение смещения
Если помните, то в команде в поле imm12 мы указали значение 2
gdb преобразовал это значение в реальное смещение. Если мы сложим
значение x3=0x81000 и значение смещения 0x8 то получим 
физический адрес значения числа `b`. Давайте выполним 
две команды `stepi` подряд и посмотрим на результат исполнения
`i reg x0 x1 x3`
```
=> 0x80008:     ldr     w1, [x3, #8]
(gdb) i reg x0
x0             0x2                 2
(gdb) stepi

Thread 1 hit Breakpoint 2, 0x000000000008000c in ?? ()
1: x/i $pc
=> 0x8000c:     add     x0, x0, x1
(gdb) stepi

Thread 1 hit Breakpoint 3, 0x0000000000080010 in ?? ()
1: x/i $pc
=> 0x80010:     hlt     #0x0
(gdb) i reg x0 x1 x3
x0             0x5                 5
x1             0x3                 3
x3             0x81000             528384
```
x0 содержит результат сложения чисел а и b которые расположены в
памяти и были загружены в регистры x0,x1
x1 содержит число `b`
x3 содержит адрес страницы данных
Поздравляю! Мы в очередной раз сложили два числа новым способом

### Программа на ассемблере
Пример на ассемблере для иллюстрации.
данные находятся в той же секции что и код поэтому 
мы можем использовать директиву .org
код не компилировался и не проверялся.
```
	.align 2
	.section .text
_start:	
	ADRP	X3, a
	LDR	X0, [X3, #0]
	LDR	X1, [X3, #8]
	ADD 	X0,X0,X1
	HLT	#0

//Page 1 contains data. Expected physical memory address 0x81000
	.org 0x1000
a:	.dword 0x2
b:	.dword 0x3

```

### Модификация для 64-бит
Скорее всего вы обратили внимания на то что есть 4 байта между
значениями а и b по адресу 0x81004, а в ассемблерном коде
я использовал директиву резервирования двойного слова.
Двойное слово - double word в архитектуре Arm AArch64 имеет размер
64-бита. Давайте модифицируем команды загрузки для работы с числами
64-бита.
[C6.2.191 LDR (immediate)](https://developer.arm.com/documentation/ddi0602/2024-12/Base-Instructions/LDR--immediate---Load-register--immediate--?lang=en)
```
31	30	29	28	27	26	25	24	23	22	21	20	19	18	17	16	15	14	13	12	11	10	9	8	7	6	5	4	3	2	1	0
1	x	1	1	1	0	0	1	0	1	imm12												Rn					Rd				
size	      |				VR		|	opc    |	
```
загружаем первое заначение в X0
size = 11b -- что соотвествует 64 битам
imm12 = 0000 0000 0000b - первое значение находится по смещению 0 
относительно начала страницы
Rd - регистр назначения x0= 0 0000b
Rn - регистр базы x3 = 0 0011b
0000 1000 0110 0000b
-------|----||-----|
imm12    Rn    Rd
транслируем команду LDR (immediate) X0, [X3, #0]
```
60 00 40 F9
```
запишем её по смещению в файле 0x0004
для команды LDR (immediate) X0, [X3, #8]
следует скорректировать смещение imm12

size = 11b -- что соотвествует 64 битам
imm12 = 0000 0000 0001b - шаг для смещения по 8 байт 
относительно начала страницы
Rd - регистр назначения x0= 0 0000b
Rn - регистр базы x3 = 0 0011b
0000 0100 0110 0001b
-------|----||-----|
imm12    Rn    Rd
```
61 04 40 F9
```
записываем команду в файл по смещению 0x0008

```
03 00 00 B0 
60 00 40 F9 
61 04 40 F9 
00 00 01 8B 
00 00 40 D4
```
Перезапускаем эмулятор.
Проверяем в gdb. 
```
(gdb) target remote localhost:1234
(gdb) c
(gdb) stepi
0x0000000000080004 in ?? ()
1: x/i $pc
=> 0x80004:     ldr     x0, [x3]
(gdb)
```
обратите внимание на то что имя регистра изменилось на x0 - это 
говорит о том что будет загружено 64-битное значение.
```
(gdb) stepi
0x0000000000080008 in ?? ()
1: x/i $pc
=> 0x80008:     ldr     x1, [x3, #8]
(gdb)
```
Как видно `#8` указывает правильное смещение для второго числа.
выполняем `stepi` два раза, и проверяем результат
`i reg x0 x1 x3`
```
(gdb) stepi

Thread 1 hit Breakpoint 2, 0x000000000008000c in ?? ()
1: x/i $pc
=> 0x8000c:     add     x0, x0, x1
(gdb) stepi

Thread 1 hit Breakpoint 3, 0x0000000000080010 in ?? ()
1: x/i $pc
=> 0x80010:     hlt     #0x0
(gdb) i reg x0 x1 x3
x0             0x5                 5
x1             0x3                 3
x3             0x81000             528384
(gdb)
```
### Итоги примера PC-relative Page
Адресация PC-relative Page гараздо гибче PC-relative, позволяет 
адресовать пространство до 4ГБ. 

- Команда ADRP позволяет задать базу для области данных с выравниванием
на границу страницы 4КБ.
- Команда ADR позволяет задать базу относительно текущего PC. Однако,
требуются некоторые преобразования, чтобы выравнять базу на границу
страницы 4KБ
- Команда LDR позволяет работать со смещением относительно базы.
- Если переместить команду LDR по другому адресу смещение 
пересчитывать не нужно, что позволяет лекго модифицировать программу. 
Следует лишь записать смещения данных относительно начала 
страницы(базы).
- Для команды LDR aссемблер автоматически пересчитает значение 
смещения для поля imm12 в зависимости от выбраной ширины 32 или 
64 бита. 
- При ручной трансляции следует следить за выбранным размером данных.
учитывать его про расчете смещения для поля imm12
- Команда LDR имеет три режима адресации post-, pre-indexed, Unsigned
offset


## Пример 3.

Loads and stores
Data processing - immediate
Data processing - register


 Data processing - register
 • Arithmetic (shifted register). [ADD, ADDS, SUB, SUBS, CMP,
  CMN, NEG, NEGS]
 • Move (register). [ MOV ]

## Руководства и справочники
### Youtube
[Youtube](https://youtu.be/nu5z6qfLNU8)
### Cправочники
* Справочное руководство по архитектуре  [Справочник по иструкциям AArch64](https://developer.arm.com/documentation/ddi0602/2024-12/?lang=en)
* Глава из руководства Chapter C3 A64 Instruction Set Overview

### Команды gdb
запуск gdb 
```
 aarch64-none-elf-gdb
```
Использованые команды gdb
```
set architecture
b *0x80000
b *0x8000C
info reg
i reg x0
i reg x1
x 0x80020
x 0x80028
display /i $pc
display /i $x0
stepi
target remote localhost:1234
c
continue

